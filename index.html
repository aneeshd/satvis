<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {
  background-color: #0b0d0e;
}

canvas {
  position: absolute;
}
svg {
  position: absolute;
  font-size: 9px;
  font-family: calibri, -apple-system, "avenir next", avenir, roboto, noto, ubuntu, "helvetica neue", helvetica, arial, sans-serif;
  background-color: #374148;
  opacity: 0.9;
  padding: 3px;
}

div.overlay {
  position: absolute;
  opacity: 0.9;
}

/* svg.overlay {
  background: black;
} */

.infopanel {
  font-size: 9px;
  font-family: calibri, -apple-system, "avenir next", avenir, roboto, noto, ubuntu, "helvetica neue", helvetica, arial, sans-serif;
  background-color: #374148;
  padding: 3px;
}

.overlay {
  pointer-events: none;
}

.active { fill: steelblue; }
.inactive { fill: burlywood; }
.range { fill: rgb(161,191,217); }

.dg .c select {
  font-size: 80%;
}

.dg input[type=text] {
  font-size: 80%;
}

.chartRow .label {
  fill: white;
}

g.tick line {
  stroke: green;
}
g.tick text {
  fill: green;
}
path.domain {
  stroke: green;
}

div.datetime {
  font-size: 12px;
  font-family: calibri, -apple-system, "avenir next", avenir, roboto, noto, ubuntu, "helvetica neue", helvetica, arial, sans-serif;
  font-weight: bold;
  text-align: center;
  color: green;
}

.boxtitle {
  fill: green;
  color: green;
  font-weight: bold;
  text-align: right;
}

.infopanel table {
  color: yellowgreen;
  border: none;
  width: 70%;
  text-align: left;
  border-collapse: collapse;
}

polyline.latencyLine2 {
  fill: none;
  stroke: aquamarine;
  stroke-width:3;
  opacity: 0.5;
}

i.fa-satellite-dish {
  font-size: 16px;
  color: steelblue;
  transform: translate(-50%, -50%);
}

i.fa-circle {
  font-size: 16px;
  color: navy;
  transform: translate(-50%, -50%);
}

i.fa-satellite {
  font-size: 18px;
  color: mediumvioletred;
  transform: translate(-50%, -50%);
}

i.selected-terminal {
  font-size: 24px;
  color: purple;
}

i.selected-pop {
  font-size: 24px;
  color: crimson;
}
</style>
<link rel="stylesheet" type="text/css" href="https://kit-pro.fontawesome.com/releases/v5.10.0/css/pro.min.css">
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo/1.9.1/d3-geo.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo-projection/2.4.0/d3-geo-projection.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-format/1.3.0/d3-format.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-queue/3.0.7/d3-queue.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
<script src="https://unpkg.com/d3-geo-zoom@1.3.1"></script>
<script src="https://unpkg.com/simple-statistics@7.0.2/dist/simple-statistics.min.js"></script>
<script src="satellite.js"></script>
<script src="solar-positions.js"></script>
<script>

const font_family = 'calibri, -apple-system, "avenir next", avenir, roboto, noto, ubuntu, "helvetica neue", helvetica, arial, sans-serif';

const CONSTELLATIONS = [
  'satellites', 
  'telesat', 
  'telesat-a', 
  'telesat-b', 
  'telesat-c', 
  'telesat-d', 
  'telesat-i', 
  'telesat-p', 
  'o3b', 
  'gx', 
  'oneweb', 
  'oneweb-a', 
  'starlink'
];

function calc_mn(sc, vc) { return Math.min(sc, d3.min(vc)); }
function calc_mx(sc, vc) { return Math.max(sc, d3.max(vc)); }

// random bit is to avoid caching: https://stackoverflow.com/questions/13053096/avoid-data-caching-when-using-d3-text/13054513
function no_cache(x) { return x + '?' + Math.floor(Math.random() * 100000); }

// https://dev.to/ycmjason/how-to-create-range-in-javascript-539i
function* range(start, end) {
    yield start;
    if (start === end) return;
    yield* range(start + 1, end);
}

// https://stackoverflow.com/a/7579799
function seconds2time(seconds) {
  var hours   = Math.floor(seconds / 3600);
  var minutes = Math.floor((seconds - (hours * 3600)) / 60);
  var seconds = seconds - (hours * 3600) - (minutes * 60);
  var time = "";

  if (hours != 0) {
    time = hours+":";
  }
  if (minutes != 0 || time !== "") {
    minutes = (minutes < 10 && time !== "") ? "0"+minutes : String(minutes);
    time += minutes+":";
  }
  if (time === "") {
    time = seconds+"s";
  }
  else {
    time += (seconds < 10) ? "0"+seconds : String(seconds);
  }
  return time;
}
function msec2time(ms) { return seconds2time(ms/1000); }

function format_ms(x) {
  return d3.formatPrefix(".1s", 1e-3)(x)+"s" // display as ms
}

// Controls
const gui = new dat.GUI();

class Controls {
  constructor() {
    this.run = true;
    this.speed = 3000;
    this.constellation = 'satellites';
    this.pops = 'pops';
    this.gateways = 'gateways';
    this.users = 'terminals';

    this.zen = false;
    this.shade = true;
    this['satellite names'] = false;
    this['sat-to-ground'] = true;
    this['sat-to-sat'] = false;
    this.FOV = false;
    this.altitude_threshold = 1100;
    this['low-altitude'] = true;
    this['high-altitude'] = true;
    this.background = 12; // winter
    this.cables = true;

    this.from_trm = "undefined";
    this.to_trm = "undefined";
    this._from_trm = undefined;
    this._to_trm = undefined;
  }

  create_controls() {
    var f1 = gui.addFolder('Simulation Options');
    f1.add(this, 'run');
    f1.add(this, 'speed');
    f1.add(this, 'constellation', CONSTELLATIONS).onChange(
      () => d3.queue().defer(d3.text, no_cache(this.constellation + ".txt"))
                      .await(function(error, satellites) {
                        if (error) throw error;
                        load_satellites(satellites);
                      }));

    f1.add(this, 'pops', ['pops', 'gx-mmp', 'o3b-pops']).onChange(
      () => d3.queue().defer(d3.tsv, no_cache(this.pops + ".txt"))
                      .await(function(error, pops) {
                        if (error) throw error;
                        load_pops(pops);
                      }));

    // reload both "gateways" and "user terminals" because we don't currently distinguish between the two
    f1.add(this, 'gateways', ['gateways', 'gx-sas', 'o3b-gateways']).onChange(
      () => d3.queue().defer(d3.tsv, no_cache(this.gateways + ".txt"))
                      .defer(d3.tsv, no_cache(this.users + ".txt"))
                      .await(function(error, gateways, users) {
                        if (error) throw error;
                        load_terminals(gateways.concat(users));
                      }));

    f1.add(this, 'users', ['terminals']).onChange(
      () => d3.queue().defer(d3.tsv, no_cache(this.gateways + ".txt"))
                      .defer(d3.tsv, no_cache(this.users + ".txt"))
                      .await(function(error, gateways, users) {
                        if (error) throw error;
                        load_terminals(gateways.concat(users));
                      }));

    f1.open();
    this.f1 = f1;

    var f2 = gui.addFolder('Display Options');
    f2.add(this, 'zen');
    // f2.add(this, 'FOV');
    // f2.add(this, 'altitude_threshold');
    // f2.add(this, 'low-altitude');//.onChange(enabled => d3.selectAll('.lowaltitude').style('display', enabled ? null : 'none'));
    // f2.add(this, 'high-altitude');//.onChange(enabled => d3.selectAll('.highaltitude').style('display', enabled ? null : 'none'));
    var f2a = f2.addFolder('Layers');
    f2a.add(this, 'background', [...range(1, 12)]).onChange(function () {
      image.src = 'https://raw.githubusercontent.com/aneeshd/earth-wallpaper/master/images/world.topo.bathy.2004' + String(control.background).padStart(2, '0') + '.3x5400x2700.jpg';
      plot_globe_with_defaults();
    });
    f2a.add(this, 'satellite names');
    f2a.add(this, 'sat-to-ground');
    f2a.add(this, 'sat-to-sat');
    f2a.add(this, 'shade');
    f2a.add(this, 'cables').onChange(() => plot_globe_with_defaults());
    f2a.close();
    f2.open();
    this.f2 = f2;
    // gui.remember(this);
  }

  reload_terminals(terminals) {
    this.f3 && gui.removeFolder(this.f3);

    this.terminals = terminals;

    var f3 = gui.addFolder("Traffic");
    var trms = terminals.map(x => x.name);
    trms.unshift('none');
    f3.add(this, "from_trm", trms).onChange(function() {
      var obj = this.object;
      try {
        obj._from_trm = obj.terminals[obj.terminals.map(x => x.name).indexOf(obj.from_trm)];
      } catch(e) {
        obj._from_trm = undefined;
      }
      obj.load_conntrack();
    });
    f3.add(this, "to_trm", trms).onChange(function() {
      var obj = this.object;
      try {
        obj._to_trm = obj.terminals[obj.terminals.map(x => x.name).indexOf(obj.to_trm)];
      } catch(e) {
        obj._to_trm = undefined;
      }
      obj.load_conntrack();
    });
    f3.open();
    this.f3 = f3;
    // gui.remember(this);
  }

  load_conntrack() {
    if (this._from_trm!=undefined && this._to_trm!=undefined) {
      this.conntrack = new ConnTrack(this._from_trm, this._to_trm);
      graph_settings = setup_graph();
    } else {
      this.conntrack = undefined;
    }
  }
}

class POP {
  constructor(name) {
    this.name = name;
    this.gw = [];
    //console.log('Created POP', name);
  }
}

var control = new Controls();
// gui.remember(control);

var RADIANS = Math.PI / 180;
var DEGREES = 180 / Math.PI;
var R_EARTH = 6378.137; // equatorial radius (km)
var SPEED_OF_LIGHT = 299792.458; // Speed of light in km/s
var SPEED_OF_LIGHT_FIBRE = SPEED_OF_LIGHT / 1.467; // ... estimate
var SQUIGGLY_PATH_FACTOR = 1.5; // fudge factor for fibre latency (direct line distance is multiplied by this factor)

// does not use the whole window to start (can't remember why); zooming will fill the window
var width = Math.floor( window.innerWidth * 0.9 );
var height = Math.floor( window.innerHeight * 0.9 );

// force control gui to be on top of everything else
d3.select("div.dg.ac")
  .style("z-index", 100)
  .style("opacity", 0.9);

var title = d3.select("body").append("div")
  .attr("class", "datetime");

var graticule = d3.geoGraticule();

var map_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var sat_canvas = d3.select("body").append("canvas")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var shade_canvas = d3.select("body").append("canvas")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var gw_overlay = d3.select("body").append("div")
    .attr("class", "overlay gw")
    .style("overflow", "hidden")
    .style("width", width+"px")
    .style("height", height+"px");

var hidden_canvas = d3.select("body").append("canvas")
  .style("display", "none")
  .attr("width", width)
  .attr("height", height);

var hidden_canvas2 = d3.select("body").append("canvas")
  .style("display", "none")
  .attr("width", width)
  .attr("height", height);

var map_context = map_canvas.node().getContext("2d");
var sat_context = sat_canvas.node().getContext("2d");
var shade_context = shade_canvas.node().getContext("2d");
var hidden_context = hidden_canvas.node().getContext("2d");
var hidden_context2 = hidden_canvas2.node().getContext("2d");
var sat_path, shade_path, map_path;

var timeFormat = d3.timeFormat("%Y-%m-%d %H:%M:%S");

var satellites = [];
var terminals = [];
var pops = new Map();

var graph_settings = undefined;

var projection;
var q = d3.queue();

window.addEventListener("resize", redraw);

var world_info = undefined;

var image = undefined;

function load_world(world_detailed, world, cables, cable_ls) {
  world_info = [world_detailed, world, cables, cable_ls];
  redraw();
}

function redraw() {

  if (world_info==undefined) return;

  var world_detailed = world_info[0],
      world = world_info[1];

  width = Math.floor( window.innerWidth );
  height = Math.floor( window.innerHeight );

  d3.selectAll("canvas")
    .attr("height", height)
    .attr("width", width);
  d3.selectAll("div.gw")
    .style("width", width+"px")
    .style("height", height+"px");

  var qid = undefined;
  function delayed_draw(callback) {
    if (qid != undefined) {
      clearTimeout(qid);
    }
    qid = setTimeout(function() {
      plotglobe(world_detailed, graticule, map_context, map_path, true);
      d3.select("div.gw").style("display","block");
      run_iteration();
      callback(null);
      qid = undefined;
    }, 0);
    return {
      abort: function() {
        clearTimeout(id);
      }
    };
  }

  projection = 
    //d3.geoOrthographic() //3d-view: clipping does not work properly yet
    //d3.geoEquirectangular()
    //d3.geoMercator()
    d3.geoProjection(d3.geoMtFlatPolarQuarticRaw)
    //d3.geoMtFlatPolarQuartic()
    //d3.geoProjection(d3.geoKavrayskiy7Raw)
      .fitSize([width*0.8, height*0.8], topojson.feature(world, world.objects.land))
      .translate([width / 2, height / 2])
      .precision(.1);

  map_path = d3.geoPath()
    .projection(projection)
    .context(map_context);

  shade_path = d3.geoPath()
    .projection(projection)
    .context(shade_context);

  sat_path = d3.geoPath()
    .projection(projection)
    .context(sat_context);

  d3.geoZoom()
    .projection(projection)
    .onMove(function() {
      // draw low resolution map while dragging, and then a detailed one when done
      d3.select("div.gw").style("display","none");
      plotglobe(world, graticule, map_context, map_path, false);
      sat_context.clearRect(0,0,width,height);
      q.defer(delayed_draw);
    })
    .northUp(true)
    (map_canvas.node());

  plotglobe(world_detailed, graticule, map_context, map_path, true);
}

function plotglobe(world, graticule, context, path, detailed) {
  context.clearRect(0,0,width,height);

  if (!detailed || (detailed && !image.complete)) {
    context.fillStyle = "rgb(9,26,43)";
    context.beginPath();
    path({type: 'Sphere'});
    context.fill();

    context.fillStyle = "rgb(248,244,240)";
    context.beginPath();
    path(topojson.feature(world, world.objects.land));
    context.fill();
  } else {
    // context.strokeStyle = "red";
    // context.beginPath();
    // path({type: 'Sphere'});
    // context.lineWidth = 10;
    // context.stroke();
  }

  if (detailed) {
    if (image.complete) {
      on_image_load();
    } else {
      console.log('image not available, defer');
      image.onload = (() => plotglobe(world, graticule, context, path, detailed));
    }
  }

  context.strokeStyle = "rgb(214,210,213)";
  context.beginPath();
  path(topojson.feature(world, world.objects.countries));
  context.lineWidth = 1;
  context.stroke();

  context.strokeStyle = "#eee";
  context.beginPath();
  path(graticule());
  context.lineWidth = 1;
  context.stroke();

  context.beginPath();
  path(graticule.outline());
  context.lineWidth = 1;
  context.stroke();

  if (control.cables) {
    context.strokeStyle = "rgba(200,200,200,0.5)";
    context.beginPath();
    path(world_info[2]);
    context.lineWidth = 2;
    context.stroke();

    context.strokeStyle = "rgba(0,100,100,0.5)";
    context.beginPath();
    path(world_info[3]);
    context.lineWidth = 2;
    context.stroke();
  }
}

function plot_globe_with_defaults() {
  plotglobe(world_info[0], graticule, map_context, map_path, true);
}

// Adapted from http://techslides.com/d3-globe-with-canvas-webgl-and-three-js
function on_image_load() {

  var dx = image.width,
      dy = image.height;

  hidden_canvas
    .attr("width", dx)
    .attr("height", dy);

  hidden_context.drawImage(image, 0, 0, dx, dy);

  // draw the sphere on a hidden context, and use that as a mask
  hidden_canvas2
    .attr("width", width)
    .attr("height", height);

  var path = d3.geoPath(projection);
  var sphere = {type:"Sphere"};
  hidden_context2.clearRect(0,0,width,height);
  hidden_context2.beginPath();
  d3.geoPath().projection(projection).context(hidden_context2)(sphere);
  hidden_context2.fillStyle='red';
  hidden_context2.fill();
  var i = hidden_context2.getImageData(0,0,width,height);
  var srcMask = i.data;

  var sourceData = hidden_context.getImageData(0, 0, dx, dy).data,
      target = map_context.createImageData(width, height),
      targetData = target.data;

  //this get it done in terms of laying the right tiles on the right projection!
  for (var y = 0, i = -1; y < height; ++y) {
    for (var x = 0; x < width; ++x) {
      // is point within the sphere? if not, just fill it in with a background colour
      if (srcMask[i+1] != 255) {
        targetData[++i] = 25;
        targetData[++i] = 25;
        targetData[++i] = 25;
        targetData[++i] = 255;
        continue;
      }

      var p = projection.invert([x, y]), λ = p[0], φ = p[1];
      if (λ > 180 || λ < -180 || φ > 90 || φ < -90) { i += 4; continue; }
      var q = ((90 - φ) / 180 * dy | 0) * dx + ((180 + λ) / 360 * dx | 0) << 2;
      targetData[++i] = sourceData[q];
      targetData[++i] = sourceData[++q];
      targetData[++i] = sourceData[++q];
      targetData[++i] = 255;
    }
  }

  map_context.clearRect(0, 0, width, height);
  map_context.putImageData(target, 0, 0);
}

function parse_lat_lng(x) {
  if (x.indexOf('°') != -1) {
    // DMS format
    // adapted from https://stackoverflow.com/questions/1140189/converting-latitude-and-longitude-to-decimal-values
    var parts = x.split(/[^\d\w\.]+/);
    var dd = Number(parts[0]) + Number(parts[1])/60 + Number(parts[2])/(60*60);

    // Don't do anything for N or E
    var direction = parts[3];
    if (direction == "S" || direction == "W") {
        dd = dd * -1;
    }
    dd = dd * RADIANS;
    return dd;
  } else {
    // decimal format
    return +x * RADIANS;
  }
}

function load_terminals(data) {
  terminals = [];
  for (pop of pops.values()) {
    pop.gw = [];
  }

  data.forEach(function(line) {
    var name = 'T_'+terminals.length;
    if (line.lat==undefined || line.lng==undefined) return;
    if (!line.name) return;
    if (line.lat.charAt(0)=='#') return;
    var t = {
      id: name,
      name: line.name || name,
      minel: (+line.minel) || 20,
      posGd: {
        latitude: parse_lat_lng(line.lat),
        longitude: parse_lat_lng(line.lng),
        height: 0
      },
      pop: undefined,
    };
    terminals.push(t);
    if (line.pop==undefined) {
      // no POP
    } else if (!pops.has(line.pop)) {
      console.log("unknown POP "+line.pop+" for GW "+t.name);
    } else {
      t.pop = pops.get(line.pop);
      pops.get(line.pop).gw.push(t);
      //console.log("GW "+t.name+" connected to "+t.pop.name+" POP");
    }
  });

  control.reload_terminals(terminals);
}

function load_pops(data) {
  pops.clear();

  data.forEach(function(line) {
    if (line.lat==undefined || line.lng==undefined) return;
    if (!line.name) return;
    var p = new POP(line.name);
    p.posGd = {
        latitude: +line.lat * RADIANS,
        longitude: +line.lng * RADIANS,
        height: 0
      }
    pops.set(line.name, p);
  });
}

// TODO
class Satellite {
  constructor(name) {
    this.name = name;
    this.tle1 = undefined;
    this.tle2 = undefined;
    this.satrec = undefined;
    this.trail = undefined; // https://github.com/bmschmidt/D3-trail
  }
}

function load_satellites(data) {
  satellites = [];

  var skip1 = false;
  var skip2 = false;
  var lineno = 0;

  var lines = data.split("\n");
  lines.forEach(function(line) {
    lineno += 1;
    line = line.trim();
    if (line.length == 0) return;
    if (line.charAt(0)=="#") return;

    if (!skip1 && line[0] == "1") {
      var obj = satellites[satellites.length-1];
      obj.tle1 = line;
      return; 
    }

    if (!skip2 && line[0] == "2") {
      var obj = satellites[satellites.length-1];
      obj.tle2 = line;
      obj.satrec = satellite.twoline2satrec(obj.tle1, obj.tle2);
      return; 
    }
    
    //if (satellites.length==11)
    //if (line.charAt(0)!='P')
    //if (line.substring(0,4)!='I_01' && line.substring(0,4)!='I_11' && line.substring(0,4)!='I_03' && line.substring(0,4)!='I_13')
    if (0)
    {
      skip1 = true;
      skip2 = true;
      return;
    }
    skip1 = false;
    skip2 = false;

    var sat = new Satellite(line.trim());
    satellites.push(sat);
  });

  control.load_conntrack();
}

  var current_time = new Date().getTime();

function run() {
  d3.timer(function(elapsed) {
    if (!control.run) return;
    run_iteration();
  });
}

function run_iteration() {
  var time = new Date(current_time+=control.speed);

  sat_context.clearRect(0,0,width,height);
  sat_context.drawImage(sat_canvas.node(),0,0);

  title.text(timeFormat(time));

  if (control.run) {
    var gmst = satellite.gstimeFromDate(
      time.getUTCFullYear(),
      time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
      time.getUTCDate(),
      time.getUTCHours(),
      time.getUTCMinutes(),
      time.getUTCSeconds()
    );

    satellites.forEach(function(d) {
      update_sat(d, time, gmst);
    });

    terminals.forEach(function(d) {
      update_terminal(d, gmst);
    });

    satellites.forEach(function(d) {
      update_sat2sat(d);
    });

    if (control.conntrack != undefined) {
      control.conntrack.update(time);
    }
  }

  // selected_sats: satellites connected to terminals being probed
  var selected_sats = [];
  if (control.conntrack != undefined) {
    selected_sats = control.conntrack.selected_sats;
    redraw_graph(time, control.conntrack.conns);
  }

  plotshade(time, shade_context, shade_path);

  satellites.forEach(function(d) {
    draw_sat(d, selected_sats);
  });

  draw_terminals_and_pops(terminals, pops);

  terminals.forEach(function(d) {
    draw_terminal(d, selected_sats);
  });

  for (d of pops.entries()) {
    if (d[0]==undefined || d[1]==undefined) continue;
    draw_pop(d[0], d[1]);
  }
};

class ConnTrack {
  constructor(gw, trm) {
    // we don't really distinguish between terminals and gateways, except by convention
    // the first element is considered the gateway; all that means at the moment is that we look for a pop/gw connection and estimate the ground latency for it
    this.gw = gw;
    this.trm = trm;
    this.conns = new Map();
    this.stats = {};
    this.stats.num_sats = [];
    this.stats.start_time = undefined;

    // if GW is attached to a POP, estimate the ground latency
    // presumably, GWs don't move, so we only have to do this calculation once
    // it's also assumed (in the current data model) that a GW is only connected to one POP
    if (gw.pop != undefined) {
      var dist_rads = d3.geoDistance(
        [gw.pop.posGd.longitude * DEGREES, gw.pop.posGd.latitude * DEGREES],
        [gw.posGd.longitude * DEGREES, gw.posGd.latitude * DEGREES]
      );
      var dist_km = R_EARTH * dist_rads;
      this.ground_latency = (dist_km / SPEED_OF_LIGHT_FIBRE) * SQUIGGLY_PATH_FACTOR;
      //console.log("ground latency", this.ground_latency, dist_rads, dist_km);
    } else {
      this.ground_latency = 0;
    }
  }

  update(time) {
    var gw_conns = this.gw.conn, trm_conns = this.trm.conn;

    // intersection of satellites connected to both gateway and terminal
    var s = new Set(gw_conns.map(x => x[0]));
    var selected_sats = trm_conns.map(x => x[0]).filter(el => s.has(el));

    var fr = new Map( gw_conns.map(x => [x[0].name, [x[1], x[1].rangeSat]]) );
    var to = new Map( trm_conns.map(x => [x[0].name, [x[1], x[1].rangeSat]]) );

    var conns = this.conns;
    var self = this;

    var data = new Map( selected_sats.map(function(s) {
      var ret = [s.name, {"latency": (((+fr.get(s.name)[1]) + (+to.get(s.name)[1])) / SPEED_OF_LIGHT + self.ground_latency) /* s */}];
      if (!conns.has(s.name)) {
        ret[1].first_seen = time;
        ret[1].initial_latency = ret[1].latency;
        ret[1].min_latency = ret[1].latency;
        ret[1].max_latency = ret[1].latency;
        ret[1].ground_latency = self.ground_latency;
      }
      return ret;
    }) );

    this.selected_sats = selected_sats;

    for (const satname of data.keys()) {
      var src = data.get(satname);
      var dst = this.conns.has(satname) ? this.conns.get(satname) : (this.conns.set(satname, {}), this.conns.get(satname));
      for (const key in src) {
        dst[key] = src[key];
      }
    }

    var nu = new Date();

    for (const satname of this.conns.keys()) {
      var s = this.conns.get(satname);
      if (data.has(satname)) {
        s.active = true;
        s.inactive_time = undefined;
        s.min_latency = Math.min(s.min_latency, s.latency);
        s.max_latency = Math.max(s.max_latency, s.latency);
        s.last_seen = time;
      } else {
        s.active = false;
        if (s.inactive_time == undefined) {
          s.inactive_time = new Date();
        }
        if (nu - s.inactive_time > 5000) {
          // remove after 5s wall time
          this.conns.delete(satname);
        }
      }
    }

    if (this.stats.start_time==undefined) this.stats.start_time=time;
    this.stats.min_latency = calc_mn(this.stats.min_latency||10000, [...this.conns.values()].map(d => d.min_latency));
    this.stats.max_latency = calc_mx(this.stats.max_latency||0, [...this.conns.values()].map(d => d.max_latency));
    this.stats.num_sats.push( selected_sats.length );
  }
}

function update_sat(sat, time, gmst) {
  var satrec = sat.satrec;

  var positionAndVelocity = satellite.propagate(
      satrec,
      time.getUTCFullYear(),
      time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
      time.getUTCDate(),
      time.getUTCHours(),
      time.getUTCMinutes(),
      time.getUTCSeconds()
  );

  if (!positionAndVelocity.position) {
    var now = new Date();
    if (time.getTime() - now.getTime() > 1000) return;
    console.log("No position data for:");
    console.log(sat, satrec);
    return;
  }

  // The position_velocity result is a key-value pair of ECI coordinates.
  // These are the base results from which all other coordinates are derived.
  var positionEci = positionAndVelocity.position,
      velocityEci = positionAndVelocity.velocity;

  var positionGd = satellite.eciToGeodetic(positionEci, gmst)
  sat.posGd = positionGd;
  sat.eci = positionEci;
  sat.ecf = satellite.eciToEcf(positionEci, gmst);
};

function update_terminal(trm, gmst) {
  trm.ecf = satellite.geodeticToEcf(trm.posGd);

  // calculate connectivity to each satellite
  trm.conn = satellites.map(function(sat) {
    try {
      return [sat, satellite.ecfToLookAngles(trm.posGd, sat.ecf)]
    } catch(e) {
      // undefined
    }
  })
  .filter(x => x!=undefined)
  // filter based on minimum look angle
  .filter(function(x) {
    var el = x[1].elevation * DEGREES;
    var min_el = trm.minel;
    return (el>=min_el && el<=(180-min_el));
  })
  ;
}

function update_sat2sat(sat) {
  if (!control['sat-to-sat']) return;

  sat.conn = satellites.map(function(s) {
    if (sat==s) return undefined;
    if (sat==undefined || s==undefined) return undefined;
    //console.log(sat, s); return;
    try {
      var h = sat.posGd.height / s.posGd.height;
      if (h>1.1 || h<0.8) return undefined; // check
      return [s, distance3d(sat.ecf, s.ecf)];
    } catch(e) {
      // undefined
    }
  })
  .filter(x => x!=undefined)
  // restrict distance (FIXME: need real criteria)
  .filter(x => x[1]>1000 && x[1]<5000)
  // TODO: restrict based on pointing limitations
  // sort by distance (closest to furthest)
  .sort((a,b) => a[1]-b[1])
  ;
}

function draw_sat(sat, selected_sats) {
  var pos = sat.posGd;

  try {
    pos.longitude
  }
  catch (e) {
    return
  }

  if (control.zen && !selected_sats.includes(sat)) return;

  var scale = 1.0;
  try {
    scale = 175.0 / projection.scale();
  } catch (e) {
  }

  var name = sat.name;
  var ln = pos.longitude * DEGREES, lt = pos.latitude * DEGREES, sz=Math.max(0.7*scale, 0.02);
  var detail = false;

  sat_context.fillStyle = pos.height > control.altitude_threshold ? "#bda0bc" : "#03cea4";
  sat_context.strokeStyle = pos.height > control.altitude_threshold ? "#bda0bc" : "#03cea4";
  if (selected_sats.indexOf(sat)!=-1) {
    sat_context.fillStyle = "#824670";
    sat_context.strokeStyle = "#824670";
    detail = true;
    sz = Math.max(0.7*scale*3, 0.02*3);
  }

  var route = get_satellite_shape(ln, lt, sz, pos.height);
  sat_context.lineWidth = 0.25;
  sat_context.beginPath();
  sat_path(route);
  sat_context.fill();

  if (control['satellite names'] || detail) {
    // FIXME does not respect geo projection if hidden
    var xy = projection([ln, lt]);
    sat_context.font = "9px sans-serif";
    sat_context.textAlign = "center";
    sat_context.fillText(name, xy[0], xy[1]+30);
  }

  if (control.FOV) {
    // super slow
    var night = getFootprint(pos);
    shade_context.beginPath();
    shade_path(night);
    shade_context.fillStyle = "rgba(255,0,255,0.01)";
    shade_context.fill();
    shade_context.strokeStyle = "rgba(60,60,60,0.1)"
    shade_context.stroke();
  }

  if (control['sat-to-sat']) {
    for (i=0; i<4; i++) {
      try {
        var s = sat.conn[i][0];
      } catch(e) {
        //console.log('error', sat.name, i);
        continue;
      }
      try {
        var route = {type: "LineString", "coordinates": [
          [s.posGd.longitude * DEGREES, s.posGd.latitude * DEGREES, s.posGd.height],
          [pos.longitude * DEGREES, pos.latitude * DEGREES, pos.height]
        ]};
        sat_context.beginPath();
        if (pos.height > control.altitude_threshold) {
          sat_context.strokeStyle = "rgba(0,0,255,0.4)";
        } else {
          sat_context.strokeStyle = "rgba(0,255,0,0.4)";
        }
        sat_context.lineWidth = 0.25;
        sat_path(route);
        sat_context.stroke();
      } catch(e) {
        console.log('error', sat.name, s.name, s);
      }
    }
  }
};

function draw_terminals_and_pops(terminals, pops) {
  var drawfn = function(data, container, icon, icon2) {
    var p = d3.select(container)
              .selectAll("i."+icon)
              .data(data);

    p.enter()
     .append("i")
     .attr("class", icon2+" "+icon)
     .style("position", "absolute");

    d3.select(container).selectAll("i."+icon)
      .classed("selected-terminal", d => (d==control._from_trm || d==control._to_trm) ? true : false)
      .classed("selected-pop", d => d==(control._from_trm && control._from_trm.pop) ? true : false)
      .style("left", d => projection([d.posGd.longitude * DEGREES, d.posGd.latitude * DEGREES])[0] + "px")
      .style("top", d => projection([d.posGd.longitude * DEGREES, d.posGd.latitude * DEGREES])[1] + "px");
  };

  drawfn(terminals, "div.gw", "fa-satellite-dish", "fas");
  drawfn([...pops.values()], "div.gw", "fa-circle", "far");

  // slow: drawfn(satellites, "div.gw", "fa-satellite", "fas");
}

function draw_terminal(trm, selected_sats) {
  var pos = trm.posGd;
  var r = trm==control._from_trm ? 6 : trm==control._to_trm ? 6 : 2;

  var ln = pos.longitude * DEGREES, lt = pos.latitude * DEGREES, sz=.2*r;

  if (control.zen) {
    if (trm!=control._from_trm && trm!=control._to_trm) return;
  }

  if (control['sat-to-ground'] || control.zen) {
    trm.conn.forEach(function(s) {
      var sat = s[0], lookangles = s[1], dist = s[1].rangeSat;

      if (control.zen) {
        if (!selected_sats.includes(sat)) return;
      }

      var el = lookangles.elevation * DEGREES;
      var min_el = trm.minel;

      if ((el>=min_el && el<=(180-min_el))) {
        var c = sat_context;
        route = {type: "LineString", "coordinates": [
          [pos.longitude * DEGREES, pos.latitude * DEGREES],
          [sat.posGd.longitude * DEGREES, sat.posGd.latitude * DEGREES]
        ]};
        if (el<(min_el+10) || el>(180-min_el-10)) {
          // warn when elevation angle is close to the allowed minimum
          c.strokeStyle = "rgba(255,0,0,0.5)";
        } else {
          c.strokeStyle = "rgba(140,140,140,0.5)";
        }
        if (selected_sats.includes(sat) && (trm==control._from_trm || trm==control._to_trm)) {
          c.lineWidth = 6;
        } else {
          c.lineWidth = 1;
        }
        c.beginPath();
        sat_path(route);
        c.stroke();
      }
    });
  }
}

function draw_pop(name, pop) {
  var pos = pop.posGd;
  var r = 3;

  var ln = pos.longitude * DEGREES, lt = pos.latitude * DEGREES, sz=.2*r;

  // POP to GW connections
  if (1) {
    pop.gw.forEach(function(gw) {
      //if (gw!=control._from_trm) return;

      route = {type: "LineString", "coordinates": [
        [pos.longitude * DEGREES, pos.latitude * DEGREES],
        [gw.posGd.longitude * DEGREES, gw.posGd.latitude * DEGREES]
      ]};
      //console.log(pop.name, gw.name);
      sat_context.beginPath();
      sat_context.lineWidth = 4;
      sat_context.strokeStyle = "rgba(128,128,0,0.5)";
      sat_path(route);
      sat_context.stroke();
    });
  }
}

function distance3d(p1, p2) {
  return Math.sqrt( (p1.x-p2.x)**2 + (p1.y-p2.y)**2 + (p1.z-p2.z)**2 );
}


// https://bl.ocks.org/tuckergordon/raw/ce135a88cd14991761ccdc937179c6c0/

/**
 * @returns {GeoJSON.Polygon} GeoJSON describing the satellite's current footprint on the Earth
 */
function getFootprint(pos) {
  var theta = /*this._halfAngle*/ 57 * RADIANS;

  coreAngle = _coreAngle(theta, pos.height, R_EARTH) * DEGREES;

  return d3.geoCircle()
    .center([pos.longitude * DEGREES, pos.latitude * DEGREES])
    .radius(coreAngle)();
};

/**
 * A conical satellite with half angle casts a circle on the Earth. Find the angle
 * from the center of the earth to the radius of this circle
 * @param {number} theta: Satellite half angle in radians
 * @param {number} altitude Satellite altitude
 * @param {number} r Earth radius
 * @returns {number} core angle in radians
 */
function _coreAngle(theta, altitude, r) {
  // if FOV is larger than Earth, assume it goes to the tangential point
  if (Math.sin(theta) > r / (altitude + r)) {
    return Math.acos(r / (r + altitude));
  }
  return Math.abs(Math.asin((r + altitude) * Math.sin(theta) / r)) - theta;
};

// https://bl.ocks.org/caravinden/eb0e5a2b38c8815919290fa838c6b63b
// http://bl.ocks.org/charlesdguthrie/11356441
function setup_graph() {

  d3.select("body").selectAll("svg.overlay").remove();
  d3.select("body").selectAll("div.infopanel").remove();

  if (control.conntrack == undefined) return;

  var settings = {};

  // set the dimensions and margins of the graph
  var margin = {top: 20, right: 20, bottom: 30, left: 50},
      width = 400 - margin.left - margin.right,
      height = (window.innerHeight * 0.8)/2,
      eheight = height - 50,
      top = 10;

  {
    // set the ranges
    var y = d3.scaleBand()
              .range([eheight, 0])
              .padding(0.1);

    var x = d3.scaleLinear()
              .range([0, width - margin.right ]);
    var x2 = d3.scaleLinear()
              .range([0, width - margin.right ]);

    // append the svg object to the body of the page
    // append a 'group' element to 'svg'
    // moves the 'group' element to the top left margin

    var svgp = d3.select("body").append("svg")
        .attr("class", "overlay")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height)
        .style("top", top);

    top += height + 10;
  
    var svg = svgp
      .append("g")
        .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");

    // add the x Axis
    var xaxis = svg.append("g")
        .attr("transform", "translate(0," + eheight + ")")
        .style('font-size', '9px')
        .style('font-family', font_family);

    var xaxis2 = svg.append("g")
      .attr("transform", "translate(0,0)")
      .style('font-size', '9px');

    // add the y Axis
    var yaxis = svg.append("g")
        .style('font-size', '9px')
        .style('font-family', font_family);

    svgp.append('text')
      .attr('x', '100%')
      .attr('y', '1em')
      .attr('text-anchor', 'end')
      .attr('class', 'boxtitle')
      .text('Latency + Dwell Time');

    settings.latdwell = {
      margin: margin, width: width, height: height,
	    svg:svg, x:x, y:y, xaxis: xaxis, yaxis: yaxis, x2: x2, xaxis2: xaxis2
    }

  }
  
  {
    height /= 2;
    eheight = height - 50;

    var svg2p = d3.select("body").append("svg")
        .attr("class", "overlay")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height)
        .style("top", top);

    top += height + 10;

    var svg2 = svg2p
      .append("g")
        .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");

    var hx = d3.scaleLinear()
      .range([0, width])
      .domain([0,20]);

    var hy = d3.scaleLinear()
      .range([eheight, 0]);

    var hyp = d3.scaleLinear()
      .range([eheight, 0]);

    var hxs = svg2.append('g')
      .attr('transform', 'translate(0,'+eheight+')')
      .style('font-size', '9px')
      .style('font-family', font_family);

    var hys = svg2.append('g')
      .style('font-size', '9px')
      .style('font-family', font_family);

    svg2p.append('text')
      .attr('x', '100%')
      .attr('y', '1em')
      .attr('text-anchor', 'end')
      .attr('class', 'boxtitle')
      .text('Visible Satellites');

    var hist = d3.histogram()
                  .domain(hx.domain())
                  .thresholds(hx.ticks(20))
                  .value(d => d);

    settings.histogram = {hist: hist, x: hx, y: hy, yp: hyp, svg: svg2, xaxis: hxs, yaxis: hys, height: height, width: width, margin: margin, data: []};
  }

  {
    var div =  d3.select("body").append("div")
        .attr("class", "overlay infopanel")
        .attr("style", "position: absolute; width:400px; height:"+height+"px; top: "+top+"px;");
    
    top += height + margin.bottom;

    div.append('div')
      .attr('x', '100%')
      .attr('y', '1em')
      .attr('text-anchor', 'end')
      .attr('class', 'boxtitle')
      .text('Connection Statistics');

    var tbl = div.append('table');
    var thead = tbl.append('thead');
    var tbody = tbl.append('tbody');

    thead.append('tr')
      .selectAll('th')
      .data(["", control.conntrack.gw.name + " ⇄ " + control.conntrack.trm.name])
      .enter()
        .append('th')
        .text(d => d);
    
    settings.infodiv = {div: div, tbl: tbl, tbody: tbody};
  }

  return settings;
}

function redraw_graph(time, data_map) {
  if (graph_settings==undefined) return;

  // temp
  var data = [];
  for (x of data_map.entries()) {
    y = x[1];
    y.sat = x[0];
    data.push(y);
  }

  var active_data = data.filter(d => d.active);
  const DURATION = 10;

  {
    var settings = graph_settings.latdwell;
    var x = settings.x,
        y = settings.y,
        xaxis = settings.xaxis,
        x2 = settings.x2,
        xaxis2 = settings.xaxis2,
        yaxis = settings.yaxis,
        margin = settings.margin,
        svg = settings.svg,
        height = settings.height - margin.top - margin.bottom,
        width = settings.width;

    // Bottom x-axis: latency
    var mx = Math.max(control.conntrack.stats.max_latency*1000, d3.max(data.map(d => d.latency*1000))); // convert to ms
    x.domain( [0, mx] ).nice();

    // Top x-axis: first_seen to last_seen (axis not shown); convert to minutes
    var mn2 = d3.min( data.map(d => d.first_seen/1000/60) );
    var mx2 = d3.max( data.map(d => d.last_seen/1000/60) );
    x2.domain( [mn2-5, mx2] ); // leave 5 minutes for disappearing satellites

    // Sort bars by first_seen time
    y.domain( data.sort((a,b) => a.first_seen-b.first_seen).map(d => d.sat) );

    //Bind new data to chart rows 

    //Create chart row and move to below the bottom of the chart
    var chartRow = svg.selectAll("g.chartRow")
      .data(data);
      
    var newRow = chartRow
      .enter()
        .append("g")
        .attr("class", "chartRow")
        .attr("transform", function(d){ return "translate(0," + y(d.sat) + ")"; });

    //Add rectangles
    newRow.insert("rect")
      .attr("class", "bar active")
      .attr("x", d => x2(d.first_seen/1000/60))
      .attr("height", y.bandwidth()/2)
      .attr("width", d => x2(d.last_seen/1000/60) - x2(d.first_seen/1000/60));

    // min/max latency
    newRow.insert("rect")
      .attr("class", "range")
      .attr("x", d => x(d.min_latency*1000))
      .attr("height", y.bandwidth()/6)
      .attr("width", d => x((d.max_latency-d.min_latency)*1000));

    //Add value labels
    newRow.append("text")
      .attr("class", "label")
      .attr("y", y.bandwidth()/2)
      .attr("x", 0)
      .attr("dy", ".35em")
      .attr("dx", "0.5em");

    //Update bar widths
    chartRow.select(".bar")
      .transition()
      .duration(DURATION)
      .attr("class", d => d.active ? "bar active" : "bar inactive")
      .attr("height", y.bandwidth())
      .attr("x", d => x2(d.first_seen/1000/60))
      .attr("width", d => x2(d.last_seen/1000/60) - x2(d.first_seen/1000/60));

    // min/max latency
    chartRow.select(".range")
      .transition()
      .duration(DURATION)
      .attr("x", d => x(d.min_latency*1000))
      .attr("height", y.bandwidth()/3)
      .attr("width", d => x((d.max_latency-d.min_latency)*1000));

    //Update data labels
    chartRow.select(".label")
      //.update()
      .transition()
      .duration(DURATION)
      .attr("y", y.bandwidth()/2)
      .text(d => d3.format(".1f")((d.last_seen - d.first_seen)/1000/60)+" min");
      
    //Fade out and remove exit elements
    chartRow.exit()
      //.transition()
      //.style("opacity", "0")
      //.attr("transform", "translate(0," + (height + margin.top + margin.bottom) + ")")
      .remove();

    //REORDER ROWS

    var delay = function(d, i) { return 200 + i * 30; };

    chartRow.merge(chartRow)
      .transition()
      //.delay(delay)
      //.duration(900)
      .duration(DURATION)
      .attr("transform", function(d){ return "translate(0," + y(d.sat) + ")"; });
      
    // update the x Axis
    xaxis
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    // Numbers on this scale are not useful; don't bother showing it
    // xaxis2
    //     .attr("transform", "translate(0,0)")
    //     .call(d3.axisTop(x2));

    // update the y Axis
    yaxis
        .call(d3.axisLeft(y));

    ///////////////////////////
    // line connecting current latency across all active satellites

    var latencyLine = svg.selectAll("g.latencyLine")
      .data([active_data])
      .raise();
      
    var newLine = latencyLine
      .enter()
        .append("g")
        .attr("class", "latencyLine");

    newLine.insert("polyline")
      .attr("class", "latencyLine2")
      .attr("opacity", 1);

    latencyLine.select(".latencyLine2")
      .transition()
      .duration(DURATION)
      .attr("points", d => d.map(z => [x(z.latency*1000), y.bandwidth()/6 + y(z.sat)]).flat());

  }

  ///////////////////////////////

  {
    var histogram = graph_settings.histogram;
    var x = histogram.x, 
        y = histogram.y, 
        yp = histogram.yp,
        margin = histogram.margin,
        height = histogram.height - margin.top - margin.bottom;

    histogram.data.push(active_data.length);
    var formatPercent = d3.format('.0%');

    var bins = histogram.hist(histogram.data);
    y.domain([0, d3.max(bins, d => d.length)]);
    yp.domain([0, d3.max(bins, d => d.length / histogram.data.length)]);
    histogram.xaxis.call(d3.axisBottom(x));
    histogram.yaxis.call(d3.axisLeft(yp).tickFormat(formatPercent));

    var chartRow = histogram.svg.selectAll("g.histCol")
      .data(bins);
      
    var newRow = chartRow
      .enter()
        .append("g")
        .attr("class", "histCol");

    //Add rectangles
    newRow.insert("rect")
      .attr("class", "bar")
      .attr("x", 0);

    chartRow.select(".bar")
      .transition()
      .duration(DURATION)
      .attr("x", 1)
      .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
      .attr("width", function(d) { return Math.max(0, x(d.x1) - x(d.x0) - 1); })
      .attr("height", function(d) { return Math.max(d.length>0 ? 2 : 0, height - y(d.length)); })
      .style("fill", "#69b3a2");
  }

  ///////////////////////////////

  {
    var infodiv = graph_settings.infodiv;
    var ct = control.conntrack;

    var fields = [
      [ 'satellites in constellation', (t) => satellites.length ],
      [ 'elapsed time', (t) => msec2time(time-t.stats.start_time) ],
      [ 'ground latency', (t) => format_ms(t.ground_latency) ],
      [ 'latency (min/max)', 
        (t) => 
          format_ms(t.stats.min_latency) + " / " +
          format_ms(t.stats.max_latency) ],
      [ '# satellites (min/med/max)',
        (t) => 
          ss.min(t.stats.num_sats) + " / " +
          ss.median(t.stats.num_sats) + " / " +
          ss.max(t.stats.num_sats) ],
    ];

    var gw = ct.gw;
    var trm = ct.trm;

    var data = [];
    for (var f of fields) {
      try {
        var d = [ f[0], f[1](ct) ];
        data.push(d);
      } catch(e) {
      }
    }

    infodiv.tbody.selectAll("tr")
      .data(data)
      .enter()
      .append("tr")
      .selectAll("td")
      .data(function(row) {
        return row;
      })
      .enter()
      .append("td");

    data = data.flat();
    var cells = infodiv.tbody.selectAll('td').nodes();
    //console.log(data, cells);
    for (i=0; i<data.length; i++) {
      cells[i].textContent = data[i];
    }
    //console.log(ct.stats);
  }

}

// adapted from:
//  https://observablehq.com/@mbostock/solar-terminator
//  https://bl.ocks.org/vasturiano/9bdeddb97d5c71f425743442761d5384
function plotshade(time, context, path) {
  context.clearRect(0,0,width,height);
  if (control.shade) {
    var sun = solarPosition(time);
    var night = d3.geoCircle()
      .radius(90)
      .center(antipode(sun))
    ();

    context.beginPath();
    path(night);
    context.fillStyle = "rgba(50,50,50,0.6)";
    context.fill();
  }
}

function get_terminal_shape(ln, lt, sz, height) {
  var circle = d3.geoCircle().center([ln, lt]).radius(sz);
  var route = circle();
  return route;
}

function get_satellite_shape(ln, lt, sz, height) {
  // much faster than the geoCircle above
  var route = {
    type: "LineString", 
    coordinates: [
      [ln-sz, lt-sz, height],
      [ln+sz, lt-sz, height],
      [ln+sz, lt+sz, height],
      [ln-sz, lt+sz, height],
      [ln-sz, lt-sz, height],
    ]};
  return route;
}

d3.select(self.frameElement).style("height", height + "px");

d3.queue()
  // slow when zooming/panning, but much better resolution: 
  .defer(d3.json, "https://raw.githubusercontent.com/d3/d3.github.com/master/world-50m.v1.json")
  // low resolution map:
  .defer(d3.json, "https://raw.githubusercontent.com/d3/d3.github.com/master/world-110m.v1.json")
  .defer(d3.tsv, no_cache("pops.txt"))
  .defer(d3.tsv, no_cache("gateways.txt"))
  .defer(d3.tsv, no_cache("terminals.txt"))
  .defer(d3.text, no_cache("satellites.txt"))
  .defer(d3.json, "https://raw.githubusercontent.com/telegeography/www.submarinecablemap.com/master/public/api/v2/cable/cable-geo.json")
  .defer(d3.json, "https://raw.githubusercontent.com/telegeography/www.submarinecablemap.com/master/public/api/v2/landing-point/landing-point-geo.json")
  .await(function(error, world_detailed, world, pops, gateways, terminals, satellites, cables, cable_ls) {
    if (error) throw error;
    image = new Image();
    image.crossOrigin = "Anonymous";
    // forked from LeszekSwirski
    image.src = 'https://raw.githubusercontent.com/aneeshd/earth-wallpaper/master/images/world.topo.bathy.200412.3x5400x2700.jpg';
    image.hidden = true;
    load_world(world_detailed, world, cables, cable_ls);
    control.create_controls();
    load_pops(pops);
    load_terminals(gateways.concat(terminals));
    load_satellites(satellites);
    run();
  });

</script>
