<!DOCTYPE html>
<meta charset="utf-8">
<style>
canvas {
  position: absolute;
}
svg {
  position: absolute;
}

.overlay {
  pointer-events:none;
}

.bar { fill: steelblue; }

.dg .c select {
  font-size: 80%;
}

.dg input[type=text] {
  font-size: 80%;
}

.chartRow .label {
  font-family: sans-serif;
  font-size: 9px;
  fill: white;
}
</style>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo/1.9.1/d3-geo.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo-projection/2.4.0/d3-geo-projection.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-format/1.3.0/d3-format.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-queue/3.0.7/d3-queue.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
<script src="https://unpkg.com/d3-geo-zoom@1.3.1"></script>
<script src="satellite.js"></script>
<script src="solar-positions.js"></script>
<script>

// Controls
const gui = new dat.GUI();

class Controls {
  constructor() {
    this.run = true;
    this.speed = 3000;
    this.constellation = 'satellites';
    this.gateways = 'gateways';
    this.users = 'terminals';

    this.shade = true;
    this['satellite names'] = false;
    this['sat-to-ground'] = true;
    this['sat-to-sat'] = false;
    this.FOV = false;

    this.from_trm = "undefined";
    this.to_trm = "undefined";
    this._from_trm = undefined;
    this._to_trm = undefined;
  }

  create_controls() {
    var f1 = gui.addFolder('Simulation Options');
    f1.add(this, 'run');
    f1.add(this, 'speed');
    f1.add(this, 'constellation', ['satellites', 'oneweb', 'starlink', 'gx']).onChange(
      () => d3.queue().defer(d3.text, this.constellation + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .await(function(error, satellites) {
                        if (error) throw error;
                        load_satellites(satellites);
                      }));

    // reload both "gateways" and "user terminals" because we don't currently distinguish between the two
    f1.add(this, 'gateways', ['gateways', 'gx-sas']).onChange(
      () => d3.queue().defer(d3.tsv, this.gateways + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .defer(d3.tsv, this.users + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .await(function(error, gateways, users) {
                        if (error) throw error;
                        load_terminals(gateways.concat(users));
                      }));

    f1.add(this, 'users', ['terminals']).onChange(
      () => d3.queue().defer(d3.tsv, this.gateways + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .defer(d3.tsv, this.users + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .await(function(error, gateways, users) {
                        if (error) throw error;
                        load_terminals(gateways.concat(users));
                      }));

    f1.open();
    this.f1 = f1;

    var f2 = gui.addFolder('Display Options');
    f2.add(this, 'satellite names');
    f2.add(this, 'sat-to-ground');
    f2.add(this, 'sat-to-sat');
    f2.add(this, 'shade');
    f2.add(this, 'FOV');
    f2.open();
    this.f2 = f2;
  }

  reload_terminals(terminals) {
    this.f3 && gui.removeFolder(this.f3);

    this.terminals = terminals;

    var f3 = gui.addFolder("Traffic");
    var trms = terminals.map(x => x.name);
    trms.unshift('none');
    f3.add(this, "from_trm", trms).onChange(function() {
      var obj = this.object;
      try {
        obj._from_trm = obj.terminals[obj.terminals.map(x => x.name).indexOf(obj.from_trm)];
      } catch(e) {
        obj._from_trm = undefined;
      }
    });
    f3.add(this, "to_trm", trms).onChange(function() {
      var obj = this.object;
      try {
        obj._to_trm = obj.terminals[obj.terminals.map(x => x.name).indexOf(obj.to_trm)];
      } catch(e) {
        obj._to_trm = undefined;
      }
    });
    f3.open();
    this.f3 = f3;
  }
}

var control = new Controls();

var RADIANS = Math.PI / 180;
var DEGREES = 180 / Math.PI;
var R_EARTH = 6378.137; // equatorial radius (km)
var SPEED_OF_LIGHT = 299792.458; // Speed of light in km/s

const width = window.innerWidth * 0.9;
const height = window.innerHeight;// * 0.9;

// force control gui to be on top of everything else
d3.select("div.dg.ac").style("z-index", 100);

var graticule = d3.geoGraticule();

var map_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var sat_canvas = d3.select("body").append("canvas")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var stats_canvas = d3.select("body").append("canvas")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var shade_canvas = d3.select("body").append("canvas")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var map_context = map_canvas.node().getContext("2d");
var sat_context = sat_canvas.node().getContext("2d");
var stats_context = stats_canvas.node().getContext("2d");
var shade_context = shade_canvas.node().getContext("2d");
var sat_path, stats_path, shade_path;

var timeFormat = d3.timeFormat("%Y-%m-%d %H:%M:%S");

var satellites = [];
var terminals = [];

var graph_settings = undefined;

var projection;

function load_world(world) {

  projection = 
    //d3.geoOrthographic()
    d3.geoProjection(d3.geoMtFlatPolarQuarticRaw)
    //d3.geoProjection(d3.geoKavrayskiy7Raw)
      .fitSize([width*0.8, height*0.8], topojson.feature(world, world.objects.land))
      .translate([width / 2, height / 2])
      .precision(.1);

  var map_path = d3.geoPath()
    .projection(projection)
    .context(map_context);

  shade_path = d3.geoPath()
    .projection(projection)
    .context(shade_context);

  sat_path = d3.geoPath()
    .projection(projection)
    .context(sat_context);

  stats_path = d3.geoPath()
    .projection(projection)
    .context(stats_context);

  d3.geoZoom()
    .projection(projection)
    .onMove(() => plotglobe(world, graticule, map_context, map_path) && sat_context.clearRect(0,0,width,height))
    .northUp(true)
    (map_canvas.node());

  plotglobe(world, graticule, map_context, map_path);
}

function plotglobe(world, graticule, context, path) {
  context.clearRect(0,0,width,height);

  context.fillStyle = "#ccc";
  context.beginPath();
  path(topojson.feature(world, world.objects.land));
  context.fill();

  context.strokeStyle = "#aaa";
  context.beginPath();
  path(topojson.feature(world, world.objects.countries));
  context.lineWidth = 1;
  context.stroke();

  context.strokeStyle = "#eee";
  context.beginPath();
  path(graticule());
  context.lineWidth = 1;
  context.stroke();

  context.beginPath();
  path(graticule.outline());
  context.lineWidth = 1;
  context.stroke();
}

function load_terminals(data) {
  terminals = [];
  data.forEach(function(line) {
    var name = 'T_'+terminals.length;
    //console.log(line);
    if (line.lat==undefined || line.lng==undefined) return;
    if (!line.name) return;
    var t = {
      id: name,
      name: line.name || name,
      minel: line.minel || 20,
      posGd: {
        latitude: +line.lat * RADIANS,
        longitude: +line.lng * RADIANS,
        height: 0
      }
    };
    terminals.push(t);
    //console.log(t.name);
  });

  control.reload_terminals(terminals);
}

function load_satellites(data) {
  satellites = [];

  var skip1 = false;
  var skip2 = false;
  var lineno = 0;

  var lines = data.split("\n");
  lines.forEach(function(line) {
    lineno += 1;
    if (line.length == 0) return;
    if (line.charAt(0)=="#") return;

    if (!skip1 && line[0] == "1") {
      var obj = satellites[satellites.length-1];
      obj.tle1 = line;
      return; 
    }

    if (!skip2 && line[0] == "2") {
      var obj = satellites[satellites.length-1];
      obj.tle2 = line;
      obj.satrec = satellite.twoline2satrec(obj.tle1, obj.tle2);
      return; 
    }
    
    //if (satellites.length==11)
    //if (line.charAt(0)!='P')
    //if (line.substring(0,4)!='I_01' && line.substring(0,4)!='I_11' && line.substring(0,4)!='I_03' && line.substring(0,4)!='I_13')
    if (0)
    {
      skip1 = true;
      skip2 = true;
      return;
    }
    skip1 = false;
    skip2 = false;
    //console.log(line, line.charAt(0));
    satellites.push({
      name: line.trim()
    });
  });
}

function run() {
  var current_time = new Date().getTime();

  d3.timer(function(elapsed) {
    if (!control.run) return;
    var time = new Date(current_time+=control.speed);
    run_iteration(time);
  });
}

function run_iteration(time) {
  stats_context.clearRect(0,0,width,height);
  stats_context.globalAlpha = 0.6;//0.95;
  stats_context.drawImage(sat_canvas.node(),0,0);
  sat_context.clearRect(0,0,width,height);
  sat_context.drawImage(stats_canvas.node(),0,0);

  stats_context.font = "bold 14px sans-serif";
  stats_context.fillStyle = "#333";
  stats_context.textAlign = "center";
  stats_context.fillText(timeFormat(time),width/2,20);

  var gmst = satellite.gstimeFromDate(
      time.getUTCFullYear(),
      time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
      time.getUTCDate(),
      time.getUTCHours(),
      time.getUTCMinutes(),
      time.getUTCSeconds()
  );

  satellites.forEach(function(d) {
    update_sat(d, time, gmst);
  });

  terminals.forEach(function(d) {
    update_terminal(d, gmst);
  });

  satellites.forEach(function(d) {
    update_sat2sat(d);
  });

  // satellites connected to both terminals
  var selected_sats = [];
  if (control._from_trm!=undefined && control._to_trm!=undefined) {
    var s=new Set(control._from_trm.conn.map(x => x[0]));
    selected_sats = control._to_trm.conn.map(x => x[0]).filter(el => s.has(el));

    var fr = new Map( control._from_trm.conn.map(x => [x[0].name, x[2]]) );
    var to = new Map( control._to_trm.conn.map(x => [x[0].name, x[2]]) );

    var data = selected_sats.map(function(s) {
      return {"sat": s.name, "latency": ((+fr.get(s.name)) + (+to.get(s.name))) / SPEED_OF_LIGHT /* s */};
    });
      
    redraw_graph(data);
  }

  plotshade(time, shade_context, shade_path);

  satellites.forEach(function(d) {
    draw_sat(d, selected_sats);
  });

  terminals.forEach(function(d) {
    draw_terminal(d, selected_sats);
  });
};

function update_sat(sat, time, gmst) {
  var satrec = sat.satrec;

  var positionAndVelocity = satellite.propagate(
      satrec,
      time.getUTCFullYear(),
      time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
      time.getUTCDate(),
      time.getUTCHours(),
      time.getUTCMinutes(),
      time.getUTCSeconds()
  );

  if (!positionAndVelocity.position) {
    var now = new Date();
    if (time.getTime() - now.getTime() > 1000) return;
    console.log("No position data for:");
    console.log(sat, satrec);
    return;
  }

  // The position_velocity result is a key-value pair of ECI coordinates.
  // These are the base results from which all other coordinates are derived.
  var positionEci = positionAndVelocity.position,
      velocityEci = positionAndVelocity.velocity;

  var positionGd = satellite.eciToGeodetic(positionEci, gmst)
  sat.posGd = positionGd;
  sat.eci = positionEci;
  sat.ecf = satellite.eciToEcf(positionEci, gmst);
};

function update_terminal(trm, gmst) {
  trm.ecf = satellite.geodeticToEcf(trm.posGd);

  // calculate connectivity to each satellite
  trm.conn = satellites.map(function(sat) {
    try {
      return [sat, satellite.ecfToLookAngles(trm.posGd, sat.ecf),  distance3d(sat.ecf, trm.ecf)]
    } catch(e) {
      // undefined
    }
  })
  .filter(x => x!=undefined)
  // filter based on minimum look angle
  .filter(function(x) {
    var el = x[1].elevation * DEGREES;
    var min_el = trm.minel;
    return (el>=min_el && el<=(180-min_el));
  })
  ;
}

function update_sat2sat(sat) {
  sat.conn = satellites.map(function(s) {
    if (sat==s) return undefined;
    if (sat==undefined || s==undefined) return undefined;
    //console.log(sat, s); return;
    try {
      var h = sat.posGd.height / s.posGd.height;
      if (h>1.1 || h<0.8) return undefined; // check
      return [s, distance3d(sat.ecf, s.ecf)];
    } catch(e) {
      // undefined
    }
  })
  .filter(x => x!=undefined)
  // restrict distance (FIXME: need real criteria)
  .filter(x => x[1]>1000 && x[1]<5000)
  // TODO: restrict based on pointing limitations
  // sort by distance (closest to furthest)
  .sort((a,b) => a[1]-b[1])
  ;
  //console.log(sat.conn);
}

function draw_sat(sat, selected_sats) {
  var pos = sat.posGd;

  try {
    pos.longitude
  }
  catch (e) {
    return
  }

  var name = sat.name;
  var ln = pos.longitude * DEGREES, lt = pos.latitude * DEGREES, sz=.4;
  var route = get_satellite_shape(ln, lt, sz, pos.height);
  var fov = false;

  sat_context.fillStyle = pos.height > 1100 ? "red" : "blue";
  sat_context.strokeStyle = pos.height > 1100 ? "red" : "blue";
  if (selected_sats.indexOf(sat)!=-1) {
    sat_context.fillStyle = "olive";
    sat_context.strokeStyle = "olive";
    fov = true;
  }
  sat_context.lineWidth = 0.25;
  sat_context.beginPath();
  sat_path(route);
  sat_context.fill();

  if (control['satellite names']) {
    // FIXME does not respect geo projection if hidden
    var xy = projection([ln, lt]);
    stats_context.font = "9px sans-serif";
    stats_context.textAlign = "center";
    stats_context.fillText(name, xy[0], xy[1]+14);
  }

  if (control.FOV || fov) {
    var night = getFootprint(pos);        
    shade_context.beginPath();
    shade_path(night);
    shade_context.fillStyle = "rgba(255,0,255,0.01)";
    shade_context.fill();
    shade_context.strokeStyle = "rgba(60,60,60,0.1)"
    shade_context.stroke();
  }

  if (control['sat-to-sat']) {
    for (i=0; i<4; i++) {
      try {
        var s = sat.conn[i][0];
      } catch(e) {
        //console.log('error', sat.name, i);
        continue;
      }
      try {
        var route = {type: "LineString", "coordinates": [
          [s.posGd.longitude * DEGREES, s.posGd.latitude * DEGREES],
          [pos.longitude * DEGREES, pos.latitude * DEGREES]
        ]};
        sat_context.beginPath();
        sat_context.strokeStyle = "rgba(0,255,0,0.4)";
        sat_context.lineWidth = 0.25;
        sat_path(route);
        sat_context.stroke();
      } catch(e) {
        console.log('error', sat.name, s.name, s);
      }
    }
  }
};

function draw_terminal(trm, selected_sats) {
  var pos = trm.posGd;
  var r = trm==control._from_trm ? 6 : trm==control._to_trm ? 6 : 2;

  var ln = pos.longitude * DEGREES, lt = pos.latitude * DEGREES, sz=.2*r;
  var route = get_terminal_shape(ln, lt, sz, pos.height);

  sat_context.fillStyle = "purple";
  sat_context.beginPath();
  sat_path(route);
  sat_context.fill();

  if (control['sat-to-ground']) {
    trm.conn.forEach(function(s) {
      var sat = s[0], lookangles = s[1], dist = s[2];
      var el = lookangles.elevation * DEGREES;
      var min_el = trm.minel;

      if ((el>=min_el && el<=(180-min_el))) {
        var c = stats_context;
        route = {type: "LineString", "coordinates": [
          [pos.longitude * DEGREES, pos.latitude * DEGREES],
          [sat.posGd.longitude * DEGREES, sat.posGd.latitude * DEGREES]
        ]};
        if (dist>sat.posGd.height*3) {
          // too far?
          c.strokeStyle = "rgba(255,0,0,1)";
        } else {
          c.strokeStyle = "rgba(140,140,140,1)";
        }
        if (selected_sats.indexOf(sat)!=-1 && (trm==control._from_trm || trm==control._to_trm)) {
          c.lineWidth = 10;
        } else {
          c.lineWidth = 1;
        }
        c.beginPath();
        stats_path(route);
        c.stroke();
      }
    });
  }
}

function distance3d(p1, p2) {
  return Math.sqrt( (p1.x-p2.x)**2 + (p1.y-p2.y)**2 + (p1.z-p2.z)**2 );
}


// https://bl.ocks.org/tuckergordon/raw/ce135a88cd14991761ccdc937179c6c0/

/**
 * @returns {GeoJSON.Polygon} GeoJSON describing the satellite's current footprint on the Earth
 */
function getFootprint(pos) {
  var theta = /*this._halfAngle*/ 57 * RADIANS;

  coreAngle = _coreAngle(theta, pos.height, R_EARTH) * DEGREES;
  //console.log(coreAngle);

  return d3.geoCircle()
    .center([pos.longitude*180/Math.PI, pos.latitude*180/Math.PI])
    .radius(coreAngle)();
};

/**
 * A conical satellite with half angle casts a circle on the Earth. Find the angle
 * from the center of the earth to the radius of this circle
 * @param {number} theta: Satellite half angle in radians
 * @param {number} altitude Satellite altitude
 * @param {number} r Earth radius
 * @returns {number} core angle in radians
 */
function _coreAngle(theta, altitude, r) {
  // if FOV is larger than Earth, assume it goes to the tangential point
  //console.log(altitude);
  if (Math.sin(theta) > r / (altitude + r)) {
    return Math.acos(r / (r + altitude));
  }
  return Math.abs(Math.asin((r + altitude) * Math.sin(theta) / r)) - theta;
};

// https://bl.ocks.org/caravinden/eb0e5a2b38c8815919290fa838c6b63b
// http://bl.ocks.org/charlesdguthrie/11356441
function setup_graph() {

  // set the dimensions and margins of the graph
  var margin = {top: 20, right: 20, bottom: 30, left: 50},
      width = 400 - margin.left - margin.right,
      height = 300 - margin.top - margin.bottom;

  // set the ranges
  var y = d3.scaleBand()
            .range([height, 0])
            .padding(0.1);

  var x = d3.scaleLinear()
            .range([0, width]);

  // append the svg object to the body of the page
  // append a 'group' element to 'svg'
  // moves the 'group' element to the top left margin
	d3.select("body").selectAll("svg").remove()

	var svg = d3.select("body").append("svg")
      .attr("class", "overlay")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", 
            "translate(" + margin.left + "," + margin.top + ")");

  // add the x Axis
  var xaxis = svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .style('font-size', '9px');

  // add the y Axis
  var yaxis = svg.append("g")
      .style('font-size', '9px');

  //Package and export settings
  var settings = {
	  margin:margin, width:width, height:height,
	  svg:svg, x:x, y:y, xaxis: xaxis, yaxis: yaxis
  }
  
	return settings;
}

var mx = 0;

function redraw_graph(data) {
  if (graph_settings==undefined) return;

  var settings = graph_settings;

  var x = settings.x,
      y = settings.y,
      xaxis = settings.xaxis,
      yaxis = settings.yaxis,
      margin = settings.margin,
      svg = settings.svg,
      height = settings.height,
      width = settings.width;

  // Scale the range of the data in the domains
  mx = Math.max((mx || 0), d3.max(data.map(d => d.latency*1000))); // convert to ms
  x.domain( [0, mx] );
  // Easier to follow if we don't reorder y
  //y.domain( data.sort((a,b) => a.latency-b.latency).map(d => d.sat) );
  y.domain( data.map(d => d.sat) );

  //Bind new data to chart rows 

	//Create chart row and move to below the bottom of the chart
	var chartRow = svg.selectAll("g.chartRow")
    .data(data);
    
	var newRow = chartRow
	  .enter()
      .append("g")
      .attr("class", "chartRow")
      .attr("transform", "translate(0," + height + margin.top + margin.bottom + ")");

  // // append the rectangles for the bar chart
  // svg.selectAll(".bar")
  //     .data(data)
  //   .enter().append("rect")
  //     .attr("class", "bar")
  //     //.attr("x", function(d) { return x(d.latency); })
  //     .attr("width", function(d) {return x(d.latency); } )
  //     .attr("y", function(d) { return y(d.sat); })
  //     .attr("height", y.bandwidth());

	//Add rectangles
	newRow.insert("rect")
	  .attr("class", "bar")
    .attr("x", 0)
	  //.attr("opacity", 0)
	  .attr("opacity", 1)
	  .attr("height", y.bandwidth())
	  .attr("width", d => x(d.latency*1000));

  //Add value labels
	newRow.append("text")
	  .attr("class", "label")
	  .attr("y", y.bandwidth()/2)
	  .attr("x", 0)
	  //.attr("opacity", 0)
	  .attr("opacity", 1)
	  .attr("dy", ".35em")
	  .attr("dx", "0.5em")
	  ;//.text(d => d.latency);

	//Update bar widths
  chartRow.select(".bar")
    .transition()
	  .duration(10)
	  .attr("height", y.bandwidth())
	  .attr("width", d => x(d.latency*1000))
	  .attr("opacity", 1);

  //Update data labels
  chartRow.select(".label")
    //.update()
    //.transition()
	  //.duration(10)
	  .attr("y", y.bandwidth()/2)
	  .attr("opacity", 1)
	  //.tween("text", function(d) { 
    //   var i = d3.interpolate(+this.textContent.replace(/\,/g,''), +d.latency);
    //   return function(t) {
    //     this.textContent = Math.round(i(t));
    //   };
    // });
    .text(d => d3.formatPrefix(".3s", 1e-3)(d.latency)+"s"); // display as ms
    
	//Fade out and remove exit elements
  chartRow.exit()
    //.transition()
	  //.style("opacity", "0")
	  //.attr("transform", "translate(0," + (height + margin.top + margin.bottom) + ")")
	  .remove();

	//REORDER ROWS

	var delay = function(d, i) { return 200 + i * 30; };

  chartRow.merge(chartRow)
    .transition()
		//.delay(delay)
		//.duration(900)
		.duration(30)
		.attr("transform", function(d){ return "translate(0," + y(d.sat) + ")"; });
    

  // update the x Axis
  xaxis
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

  // update the y Axis
  yaxis
      .call(d3.axisLeft(y));
}

// adapted from:
//  https://observablehq.com/@mbostock/solar-terminator
//  https://bl.ocks.org/vasturiano/9bdeddb97d5c71f425743442761d5384
function plotshade(time, context, path) {
  context.clearRect(0,0,width,height);
  if (control.shade) {
    var sun = solarPosition(time);
    var night = d3.geoCircle()
      .radius(90)
      .center(antipode(sun))
    ();

    context.beginPath();
    path(night);
    context.fillStyle = "rgba(0,0,255,0.1)";
    context.fill();
  }
}

function get_terminal_shape(ln, lt, sz, height) {
  var route = {
    type: "LineString", 
    coordinates: [
      [ln-sz, lt-sz, height],
      [ln+sz, lt-sz, height],
      [ln+sz, lt+sz, height],
      [ln-sz, lt+sz, height],
      [ln-sz, lt-sz, height],
    ]};
  return route;
}

function get_satellite_shape(ln, lt, sz, height) {
  return get_terminal_shape(ln, lt, sz, height);
}

d3.select(self.frameElement).style("height", height + "px");

graph_settings = setup_graph();

// random bit is to avoid caching: https://stackoverflow.com/questions/13053096/avoid-data-caching-when-using-d3-text/13054513
d3.queue()
  // slow: .defer(d3.json, "https://raw.githubusercontent.com/d3/d3.github.com/master/world-50m.v1.json")
  .defer(d3.json, "https://raw.githubusercontent.com/d3/d3.github.com/master/world-110m.v1.json")
  .defer(d3.tsv, "gateways.txt"+ '?' + Math.floor(Math.random() * 100000))
  .defer(d3.tsv, "terminals.txt"+ '?' + Math.floor(Math.random() * 100000))
  .defer(d3.text, "satellites.txt"+ '?' + Math.floor(Math.random() * 100000))
  .await(function(error, world, gateways, terminals, satellites) {
    if (error) throw error;
    load_world(world);
    control.create_controls();
    load_terminals(gateways.concat(terminals));
    load_satellites(satellites);
    run();
  });

</script>
