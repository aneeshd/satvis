<!DOCTYPE html>
<meta charset="utf-8">
<style>
canvas {
  position: absolute;
}
svg {
  position: absolute;
}
</style>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo/1.9.1/d3-geo.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo-projection/2.4.0/d3-geo-projection.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.js"></script>
<script src="//unpkg.com/d3-geo-zoom"></script>
<script src="satellite.js"></script>
<script src="solar-positions.js"></script>
<script>

// Controls
const gui = new dat.GUI();
// const controls = {
//   'Volcanoes': true,
//   'Graticule Grid': true,
//   'Tectonic Plates': true,
//   'Voronoi Layer': false,
//   'Shade': true
// };
var Controls = function() {
  this.run = true;
  this.speed = 300;

  this.shade = true;
  this['satellite names'] = false;
  this.FOV = false;
}
var control = new Controls();
// gui.add(controls, 'Volcanoes').onChange(enabled => d3.selectAll('.volcano').style('display', enabled ? null : 'none'));
// gui.add(controls, 'Graticule Grid').onChange(enabled => d3.selectAll('.graticule').style('display', enabled ? null : 'none'));
// gui.add(controls, 'Tectonic Plates').onChange(enabled => d3.selectAll('.plate').style('display', enabled ? null : 'none'));
// gui.add(controls, 'Voronoi Layer').onChange(enabled => d3.selectAll('.voronoi').style('display', enabled ? null : 'none'));

var f1 = gui.addFolder('Simulation Options');
f1.add(control, 'run');
f1.add(control, 'speed');
f1.open();

var f2 = gui.addFolder('Display Options');
//f2.add(control, 'names');
f2.add(control, 'satellite names');
f2.add(control, 'shade');//.onChange(enabled => d3.selectAll('.urquhart').style('display', enabled ? null : 'none'));
f2.add(control, 'FOV');
// f2.add(text, 'growthSpeed');
// f2.add(text, 'maxSize');
// f2.add(text, 'message');
f2.open();

const width = window.innerWidth * 0.8;
const height = window.innerHeight * 0.8;

var radius = height / 2 - 5,
    scale = radius,
    velocity = .02;

var graticule = d3.geoGraticule();

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);
var g = svg.append("g");

var map_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var sat_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var stats_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var shade_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var color = d3.scaleOrdinal()
  .range(["#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#ffffbf","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2"]);

var map_context = map_canvas.node().getContext("2d");
var sat_context = sat_canvas.node().getContext("2d");
var stats_context = stats_canvas.node().getContext("2d");
var shade_context = shade_canvas.node().getContext("2d");


var timeFormat = d3.timeFormat("%Y-%m-%d %H:%M");

var stations = [];

d3.json("world-110m.json", function(error, world) {
  if (error) throw error;

  var projection = 
    //d3.geoOrthographic()
    d3.geoProjection(d3.geoMtFlatPolarQuarticRaw)
    //d3.geoProjection(d3.geoKavrayskiy7Raw)
      //.scale(150)
      .fitSize([width*0.8, height*0.8], topojson.feature(world, world.objects.land))
      .translate([width / 2, height / 2])
      .precision(.1);

  // d3.geoZoom()
  //   .projection(projection)
  //   (map_canvas.node());

  var path = d3.geoPath()
    .projection(projection)
    .context(map_context);

  var shade_path = d3.geoPath()
    .projection(projection)
    .context(shade_context);

  function plotglobe() {
    var land = topojson.feature(world, world.objects.land);

    map_context.clearRect(0,0,width,height);

    map_context.fillStyle = "#ccc";
    map_context.beginPath();
    path(land);
    map_context.fill();

    map_context.fillStyle = "#555";
    map_context.beginPath();
    path(topojson.feature(world, world.objects.countries));
    map_context.lineWidth = 0.1;
    map_context.stroke();

    map_context.strokeStyle = "#ddd";
    map_context.beginPath();
    path(graticule());
    map_context.lineWidth = 1;
    map_context.stroke();

    map_context.beginPath();
    path(graticule.outline());
    map_context.lineWidth = 1;
    map_context.stroke();
  }

  // adapted from:
  //  https://observablehq.com/@mbostock/solar-terminator
  //  https://bl.ocks.org/vasturiano/9bdeddb97d5c71f425743442761d5384
  function plotshade(time) {
    shade_context.clearRect(0,0,width,height);
    if (control.shade) {
      var sun = solarPosition(time);
      var night = d3.geoCircle()
        .radius(90)
        .center(antipode(sun))
      ()
        
      shade_context.beginPath();
      shade_path(night);
      shade_context.fillStyle = "rgba(0,0,255,0.1)";
      shade_context.fill();
    }
  }

  plotglobe();

  d3.text("satellites.txt", function(error2, data) {
    if (error2) throw error2;

    stations = [];

    var lines = data.split("\n");
    lines.forEach(function(line) {
      if (line.length == 0) return;

      if (line[0] == "1") {
        var obj = stations[stations.length-1];
        obj.tle1 = line;
        return; 
      }

      if (line[0] == "2") {
        var obj = stations[stations.length-1];
        obj.tle2 = line;
        obj.satrec = satellite.twoline2satrec(obj.tle1, obj.tle2);
        return; 
      }
      
      //if (stations.length==12) return;
      stations.push({
        name: line.trim()
      });
    });

    var now = new Date();

    d3.timer(function(elapsed) {
      var time = new Date(now.getTime() + control.speed*elapsed);

      if (!control.run) return;

      if (0) {
         const config = {
                 speed: 0.005,
                 verticalTilt: -30,
                 horizontalTilt: 0
               }
         projection.rotate([config.speed * elapsed - 120, config.verticalTilt, config.horizontalTilt]);
         plotglobe();
      }
      
      stats_context.clearRect(0,0,width,height);
      stats_context.globalAlpha = .95;
      stats_context.drawImage(sat_canvas.node(),0,0);
      sat_context.clearRect(0,0,width,height);
      sat_context.drawImage(stats_canvas.node(),0,0);

      // stats_context.clearRect(0,0,width,height);
      stats_context.font = "bold 14px sans-serif";
      stats_context.fillStyle = "#333";
      stats_context.textAlign = "center";
      stats_context.fillText(timeFormat(time),width/2,20);

      plotshade(time);
      stations.forEach(function(d) {
        plotsat(d, time);
      });

      // plotshade(time);
    });

    function plotsat(station, time) {
      var satrec = station.satrec; //satellite.twoline2satrec(station.tle1, station.tle2);

      // increment time by 5 minutes

      var positionAndVelocity = satellite.propagate(
          satrec,
          time.getUTCFullYear(),
          time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
          time.getUTCDate(),
          time.getUTCHours(),
          time.getUTCMinutes(),
          time.getUTCSeconds()
      );

      if (!positionAndVelocity.position) {
        if (time.getTime() - now.getTime() > 1000) return;
        console.log("No position data for:");
        console.log(station, satrec);
        return;
      }

      var gmst = satellite.gstimeFromDate(
          time.getUTCFullYear(),
          time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
          time.getUTCDate(),
          time.getUTCHours(),
          time.getUTCMinutes(),
          time.getUTCSeconds()
      );

      // The position_velocity result is a key-value pair of ECI coordinates.
      // These are the base results from which all other coordinates are derived.
      var positionEci = positionAndVelocity.position,
          velocityEci = positionAndVelocity.velocity;

      var positionGd = satellite.eciToGeodetic(positionEci, gmst)
      station.pos = positionGd;
      drawSat(station, positionGd);
    };
  });

  function drawSat(sat, pos) {
    var name = sat.name;
    var xy = projection([pos.longitude*180/Math.PI, pos.latitude*180/Math.PI]);
    sat_context.fillStyle = color(name.substring(0,5));
    sat_context.beginPath();
    sat_context.arc(xy[0],xy[1],2,0,2*Math.PI);
    sat_context.fill();

    if (control['satellite names']) {
      stats_context.font = "9px sans-serif";
      stats_context.textAlign = "center";
      stats_context.fillText(name, xy[0], xy[1]+14);
    }

    var night = getFootprint(pos);        
    if (control.FOV) {
      // var night = getFootprint(pos);        
      shade_context.beginPath();
      shade_path(night);
      shade_context.fillStyle = "rgba(255,0,255,0.01)";
      shade_context.fill();
      shade_context.strokeStyle = "rgba(60,60,60,0.1)"
      shade_context.stroke();
    }
  };
});

// https://bl.ocks.org/tuckergordon/raw/ce135a88cd14991761ccdc937179c6c0/

  var RADIANS = Math.PI / 180;
  var DEGREES = 180 / Math.PI;
  var R_EARTH = 6378.137; // equatorial radius (km)

  /**
   * @returns {GeoJSON.Polygon} GeoJSON describing the satellite's current footprint on the Earth
   */
   //Satellite.prototype.getFootprint = function () {
  var getFootprint = function(pos) {
    var theta = /*this._halfAngle*/ 57 * RADIANS;

    coreAngle = _coreAngle(theta, pos.height, R_EARTH) * DEGREES;
    //console.log(coreAngle);

    return d3.geoCircle()
      .center([pos.longitude*180/Math.PI, pos.latitude*180/Math.PI])
      .radius(coreAngle)();
  };

  /**
   * A conical satellite with half angle casts a circle on the Earth. Find the angle
   * from the center of the earth to the radius of this circle
   * @param {number} theta: Satellite half angle in radians
   * @param {number} altitude Satellite altitude
   * @param {number} r Earth radius
   * @returns {number} core angle in radians
   */
  var _coreAngle = function (theta, altitude, r) {
    // if FOV is larger than Earth, assume it goes to the tangential point
    //console.log(altitude);
    if (Math.sin(theta) > r / (altitude + r)) {
      return Math.acos(r / (r + altitude));
    }
    return Math.abs(Math.asin((r + altitude) * Math.sin(theta) / r)) - theta;
  };

d3.select(self.frameElement).style("height", height + "px");

</script>
