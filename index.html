<!DOCTYPE html>
<meta charset="utf-8">
<style>
body {
  background-color: #0b0d0e;
}

canvas {
  position: absolute;
  top: 0;
}
svg {
  position: absolute;
  font-size: 9px;
  font-family: calibri, -apple-system, "avenir next", avenir, roboto, noto, ubuntu, "helvetica neue", helvetica, arial, sans-serif;
  background-color: #374148;
  opacity: 0.9;
  padding: 3px;
}

.overlay {
  pointer-events: none;
}

.active { fill: steelblue; }
.inactive { fill: burlywood; }
.range { fill: rgb(161,191,217); }

.dg .c select {
  font-size: 80%;
}

.dg input[type=text] {
  font-size: 80%;
}

.chartRow .label {
  fill: white;
}

g.tick line {
  stroke: green;
}
g.tick text {
  fill: green;
}

div.datetime {
  font-size: 12px;
  font-family: calibri, -apple-system, "avenir next", avenir, roboto, noto, ubuntu, "helvetica neue", helvetica, arial, sans-serif;
  text-align: center;
  color: green;
}

text.boxtitle {
  fill: green;
  font-weight: bold;
}
</style>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo/1.9.1/d3-geo.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo-projection/2.4.0/d3-geo-projection.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-format/1.3.0/d3-format.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-queue/3.0.7/d3-queue.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
<script src="https://unpkg.com/d3-geo-zoom@1.3.1"></script>
<script src="satellite.js"></script>
<script src="solar-positions.js"></script>
<script>

const font_family = 'calibri, -apple-system, "avenir next", avenir, roboto, noto, ubuntu, "helvetica neue", helvetica, arial, sans-serif';

// Controls
const gui = new dat.GUI();

class Controls {
  constructor() {
    this.run = true;
    this.speed = 3000;
    this.constellation = 'satellites';
    this.pops = 'pops';
    this.gateways = 'gateways';
    this.users = 'terminals';

    this.zen = false;
    this.shade = true;
    this['satellite names'] = false;
    this['sat-to-ground'] = true;
    this['sat-to-sat'] = false;
    this.FOV = false;
    this.altitude_threshold = 1100;
    this['low-altitude'] = true;
    this['high-altitude'] = true;

    this.from_trm = "undefined";
    this.to_trm = "undefined";
    this._from_trm = undefined;
    this._to_trm = undefined;
  }

  create_controls() {
    var f1 = gui.addFolder('Simulation Options');
    f1.add(this, 'run');
    f1.add(this, 'speed');
    f1.add(this, 'constellation', ['satellites', 'telesat', 'oneweb', 'starlink', 'gx']).onChange(
      () => d3.queue().defer(d3.text, this.constellation + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .await(function(error, satellites) {
                        if (error) throw error;
                        load_satellites(satellites);
                      }));

    f1.add(this, 'pops', ['pops', 'gx-mmp']).onChange(
      () => d3.queue().defer(d3.tsv, this.pops + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .await(function(error, pops) {
                        if (error) throw error;
                        load_pops(pops);
                      }));

    // reload both "gateways" and "user terminals" because we don't currently distinguish between the two
    f1.add(this, 'gateways', ['gateways', 'gx-sas']).onChange(
      () => d3.queue().defer(d3.tsv, this.gateways + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .defer(d3.tsv, this.users + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .await(function(error, gateways, users) {
                        if (error) throw error;
                        load_terminals(gateways.concat(users));
                      }));

    f1.add(this, 'users', ['terminals']).onChange(
      () => d3.queue().defer(d3.tsv, this.gateways + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .defer(d3.tsv, this.users + ".txt"+ '?' + Math.floor(Math.random() * 100000))
                      .await(function(error, gateways, users) {
                        if (error) throw error;
                        load_terminals(gateways.concat(users));
                      }));

    f1.open();
    this.f1 = f1;

    var f2 = gui.addFolder('Display Options');
    f2.add(this, 'zen');
    f2.add(this, 'satellite names');
    f2.add(this, 'sat-to-ground');
    f2.add(this, 'sat-to-sat');
    f2.add(this, 'shade');
    // f2.add(this, 'FOV');
    // f2.add(this, 'altitude_threshold');
    // f2.add(this, 'low-altitude');//.onChange(enabled => d3.selectAll('.lowaltitude').style('display', enabled ? null : 'none'));
    // f2.add(this, 'high-altitude');//.onChange(enabled => d3.selectAll('.highaltitude').style('display', enabled ? null : 'none'));
    f2.open();
    this.f2 = f2;
    // gui.remember(this);
  }

  reload_terminals(terminals) {
    this.f3 && gui.removeFolder(this.f3);

    this.terminals = terminals;

    var f3 = gui.addFolder("Traffic");
    var trms = terminals.map(x => x.name);
    trms.unshift('none');
    f3.add(this, "from_trm", trms).onChange(function() {
      var obj = this.object;
      try {
        obj._from_trm = obj.terminals[obj.terminals.map(x => x.name).indexOf(obj.from_trm)];
      } catch(e) {
        obj._from_trm = undefined;
      }
      if (obj._from_trm!=undefined && obj._to_trm!=undefined) {
        obj.conntrack = new ConnTrack(obj._from_trm, obj._to_trm);
        graph_settings = setup_graph();
      } else {
        obj.conntrack = undefined;
      }
    });
    f3.add(this, "to_trm", trms).onChange(function() {
      var obj = this.object;
      try {
        obj._to_trm = obj.terminals[obj.terminals.map(x => x.name).indexOf(obj.to_trm)];
      } catch(e) {
        obj._to_trm = undefined;
      }
      if (obj._from_trm!=undefined && obj._to_trm!=undefined) {
        obj.conntrack = new ConnTrack(obj._from_trm, obj._to_trm);
        graph_settings = setup_graph();
      } else {
        obj.conntrack = undefined;
      }
    });
    f3.open();
    this.f3 = f3;
    // gui.remember(this);
  }
}

class POP {
  constructor(name) {
    this.name = name;
    this.gw = [];
    console.log('Created POP', name);
  }
}

var control = new Controls();
// gui.remember(control);

var RADIANS = Math.PI / 180;
var DEGREES = 180 / Math.PI;
var R_EARTH = 6378.137; // equatorial radius (km)
var SPEED_OF_LIGHT = 299792.458; // Speed of light in km/s
var SPEED_OF_LIGHT_FIBRE = SPEED_OF_LIGHT / 1.467; // ... estimate

// use the whole window to start; zoom out if you want
const width = window.innerWidth;
const height = window.innerHeight;

// force control gui to be on top of everything else
d3.select("div.dg.ac")
  .style("z-index", 100)
  .style("opacity", 0.9);

var title = d3.select("body").append("div")
  .attr("class", "overlay datetime");

var graticule = d3.geoGraticule();

var map_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var sat_canvas = d3.select("body").append("canvas")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var stats_canvas = d3.select("body").append("canvas")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var shade_canvas = d3.select("body").append("canvas")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var map_context = map_canvas.node().getContext("2d");
var sat_context = sat_canvas.node().getContext("2d");
var stats_context = stats_canvas.node().getContext("2d");
var shade_context = shade_canvas.node().getContext("2d");
var sat_path, stats_path, shade_path;

var timeFormat = d3.timeFormat("%Y-%m-%d %H:%M:%S");

var satellites = [];
var terminals = [];
var pops = new Map();

var graph_settings = undefined;

var projection;
var q = d3.queue();

function load_world(world_detailed, world) {

  var qid = undefined;
  function delayed_draw(callback) {
    if (qid != undefined) {
      clearTimeout(qid);
    }
    qid = setTimeout(function() {
      plotglobe(world_detailed, graticule, map_context, map_path);
      callback(null);
      qid = undefined;
    }, 0);
    return {
      abort: function() {
        clearTimeout(id);
      }
    };
  }

  projection = 
    //d3.geoOrthographic()
    d3.geoProjection(d3.geoMtFlatPolarQuarticRaw)
    //d3.geoProjection(d3.geoKavrayskiy7Raw)
      .fitSize([width*0.8, height*0.8], topojson.feature(world, world.objects.land))
      .translate([width / 2, height / 2])
      .precision(.1);

  var map_path = d3.geoPath()
    .projection(projection)
    .context(map_context);

  shade_path = d3.geoPath()
    .projection(projection)
    .context(shade_context);

  sat_path = d3.geoPath()
    .projection(projection)
    .context(sat_context);

  stats_path = d3.geoPath()
    .projection(projection)
    .context(stats_context);

  d3.geoZoom()
    .projection(projection)
    .onMove(function() {
      // draw low resolution map while dragging, and then a detailed one when done
      plotglobe(world, graticule, map_context, map_path);
      sat_context.clearRect(0,0,width,height);
      q.defer(delayed_draw);
    })
    .northUp(true)
    (map_canvas.node());

  plotglobe(world_detailed, graticule, map_context, map_path);
}

function plotglobe(world, graticule, context, path) {
  context.clearRect(0,0,width,height);

  context.fillStyle = "rgb(9,26,43";
  context.beginPath();
  path({type: 'Sphere'});
  context.fill();

  context.fillStyle = "rgb(248,244,240)";
  context.beginPath();
  path(topojson.feature(world, world.objects.land));
  context.fill();

  context.strokeStyle = "rgb(214,210,213)";
  context.beginPath();
  path(topojson.feature(world, world.objects.countries));
  context.lineWidth = 1;
  context.stroke();

  context.strokeStyle = "#eee";
  context.beginPath();
  path(graticule());
  context.lineWidth = 1;
  context.stroke();

  context.beginPath();
  path(graticule.outline());
  context.lineWidth = 1;
  context.stroke();
}

function load_terminals(data) {
  terminals = [];
  //pops.clear();
  for (pop of pops.values()) {
    pop.gw = [];
  }

  data.forEach(function(line) {
    var name = 'T_'+terminals.length;
    //console.log(line);
    if (line.lat==undefined || line.lng==undefined) return;
    if (!line.name) return;
    var t = {
      id: name,
      name: line.name || name,
      minel: (+line.minel) || 20,
      posGd: {
        latitude: +line.lat * RADIANS,
        longitude: +line.lng * RADIANS,
        height: 0
      },
      pop: undefined,
    };
    terminals.push(t);
    if (line.pop==undefined) {
      // no POP
    } else if (!pops.has(line.pop)) {
      console.log("unknown POP "+line.pop+" for GW "+t.name);
    } else {
      t.pop = pops.get(line.pop);
      pops.get(line.pop).gw.push(t);
      console.log("GW "+t.name+" connected to "+t.pop.name+" POP");
    }
    //console.log(t.name);
  });

  control.reload_terminals(terminals);
}

function load_pops(data) {
  pops.clear();

  data.forEach(function(line) {
    //var name = 'T_'+terminals.length;
    console.log(line);
    if (line.lat==undefined || line.lng==undefined) return;
    if (!line.name) return;
    var p = new POP(line.name);
    p.posGd = {
        latitude: +line.lat * RADIANS,
        longitude: +line.lng * RADIANS,
        height: 0
      }
    pops.set(line.name, p);
    //console.log(t.name);
  });

  //control.reload_terminals(terminals);
}

function load_satellites(data) {
  satellites = [];

  var skip1 = false;
  var skip2 = false;
  var lineno = 0;

  var lines = data.split("\n");
  lines.forEach(function(line) {
    lineno += 1;
    line = line.trim();
    if (line.length == 0) return;
    if (line.charAt(0)=="#") return;

    if (!skip1 && line[0] == "1") {
      var obj = satellites[satellites.length-1];
      obj.tle1 = line;
      return; 
    }

    if (!skip2 && line[0] == "2") {
      var obj = satellites[satellites.length-1];
      obj.tle2 = line;
      obj.satrec = satellite.twoline2satrec(obj.tle1, obj.tle2);
      return; 
    }
    
    //if (satellites.length==11)
    //if (line.charAt(0)!='P')
    //if (line.substring(0,4)!='I_01' && line.substring(0,4)!='I_11' && line.substring(0,4)!='I_03' && line.substring(0,4)!='I_13')
    if (0)
    {
      skip1 = true;
      skip2 = true;
      return;
    }
    skip1 = false;
    skip2 = false;
    //console.log(line, line.charAt(0));
    satellites.push({
      name: line.trim()
    });
  });

  graph_settings = setup_graph();
}

function run() {
  var current_time = new Date().getTime();

  d3.timer(function(elapsed) {
    if (!control.run) return;
    var time = new Date(current_time+=control.speed);
    run_iteration(time);
  });
}

function run_iteration(time) {
  stats_context.clearRect(0,0,width,height);
  stats_context.globalAlpha = 0;
  stats_context.drawImage(sat_canvas.node(),0,0);
  sat_context.clearRect(0,0,width,height);
  sat_context.drawImage(stats_canvas.node(),0,0);

  title.text(timeFormat(time));

  var gmst = satellite.gstimeFromDate(
      time.getUTCFullYear(),
      time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
      time.getUTCDate(),
      time.getUTCHours(),
      time.getUTCMinutes(),
      time.getUTCSeconds()
  );

  satellites.forEach(function(d) {
    update_sat(d, time, gmst);
  });

  terminals.forEach(function(d) {
    update_terminal(d, gmst);
  });

  satellites.forEach(function(d) {
    update_sat2sat(d);
  });

  // selected_sats: satellites connected to terminals being probed
  var selected_sats = [];
  if (control.conntrack != undefined) {
    control.conntrack.update(time);
    selected_sats = control.conntrack.selected_sats;
    redraw_graph(control.conntrack.conns);
  }

  plotshade(time, shade_context, shade_path);

  satellites.forEach(function(d) {
    draw_sat(d, selected_sats);
  });

  terminals.forEach(function(d) {
    draw_terminal(d, selected_sats);
  });

  for (d of pops.entries()) {
    if (d[0]==undefined || d[1]==undefined) continue;
    draw_pop(d[0], d[1]);
  }
};

class ConnTrack {
  constructor(gw, trm) {
    this.gw = gw;
    this.trm = trm;
    this.conns = new Map();

    // if GW is attached to a POP, estimate the ground latency
    // presumably, GWs don't move, so we only have to do this calculation once
    // it's also assumed (in the current data model) that a GW is only connected to one POP
    if (gw.pop != undefined) {
      var dist_rads = d3.geoDistance(
        [gw.pop.posGd.longitude * DEGREES, gw.pop.posGd.latitude * DEGREES],
        [gw.posGd.longitude * DEGREES, gw.posGd.latitude * DEGREES]
      );
      var dist_km = R_EARTH * dist_rads;
      this.ground_latency = dist_km / SPEED_OF_LIGHT_FIBRE;
      console.log("ground latency", this.ground_latency, dist_rads, dist_km);
    } else {
      this.ground_latency = 0;
    }
  }

  update(time) {
    var gw_conns = this.gw.conn, trm_conns = this.trm.conn;

    var s = new Set(gw_conns.map(x => x[0]));
    var selected_sats = trm_conns.map(x => x[0]).filter(el => s.has(el));

    var fr = new Map( gw_conns.map(x => [x[0].name, [x[1], x[2]]]) );
    var to = new Map( trm_conns.map(x => [x[0].name, [x[1], x[2]]]) );

    var conns = this.conns;
    var self = this;

    var data = new Map( selected_sats.map(function(s) {
      var ret = [s.name, {"latency": (((+fr.get(s.name)[1]) + (+to.get(s.name)[1])) / SPEED_OF_LIGHT + self.ground_latency) /* s */}];
      if (!conns.has(s.name)) {
        ret[1].first_seen = time;
        ret[1].initial_latency = ret[1].latency;
        ret[1].min_latency = ret[1].latency;
        ret[1].max_latency = ret[1].latency;
        ret[1].ground_latency = self.ground_latency;
      }
      return ret;
    }) );

    this.selected_sats = selected_sats;

    for (const satname of data.keys()) {
      var src = data.get(satname);
      var dst = this.conns.has(satname) ? this.conns.get(satname) : (this.conns.set(satname, {}), this.conns.get(satname));
      for (const key in src) {
        dst[key] = src[key];
      }
    }
    for (const satname of this.conns.keys()) {
      var s = this.conns.get(satname);
      if (data.has(satname)) {
        s.active = true;
        s.inactive_count = 0;
        s.min_latency = Math.min(s.min_latency, s.latency);
        s.max_latency = Math.max(s.max_latency, s.latency);
        s.last_seen = time;
      } else {
        s.active = false;
        s.inactive_count += 1;
        if (s.inactive_count==100) {
          this.conns.delete(satname);
        }
      }
    }
    // console.log(this.conns);
  }
}

function update_sat(sat, time, gmst) {
  var satrec = sat.satrec;

  var positionAndVelocity = satellite.propagate(
      satrec,
      time.getUTCFullYear(),
      time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
      time.getUTCDate(),
      time.getUTCHours(),
      time.getUTCMinutes(),
      time.getUTCSeconds()
  );

  if (!positionAndVelocity.position) {
    var now = new Date();
    if (time.getTime() - now.getTime() > 1000) return;
    console.log("No position data for:");
    console.log(sat, satrec);
    return;
  }

  // The position_velocity result is a key-value pair of ECI coordinates.
  // These are the base results from which all other coordinates are derived.
  var positionEci = positionAndVelocity.position,
      velocityEci = positionAndVelocity.velocity;

  var positionGd = satellite.eciToGeodetic(positionEci, gmst)
  sat.posGd = positionGd;
  sat.eci = positionEci;
  sat.ecf = satellite.eciToEcf(positionEci, gmst);
};

function update_terminal(trm, gmst) {
  trm.ecf = satellite.geodeticToEcf(trm.posGd);

  // calculate connectivity to each satellite
  trm.conn = satellites.map(function(sat) {
    try {
      return [sat, satellite.ecfToLookAngles(trm.posGd, sat.ecf),  distance3d(sat.ecf, trm.ecf)]
    } catch(e) {
      // undefined
    }
  })
  .filter(x => x!=undefined)
  // filter based on minimum look angle
  .filter(function(x) {
    var el = x[1].elevation * DEGREES;
    var min_el = trm.minel;
    return (el>=min_el && el<=(180-min_el));
  })
  ;
}

function update_sat2sat(sat) {
  sat.conn = satellites.map(function(s) {
    if (sat==s) return undefined;
    if (sat==undefined || s==undefined) return undefined;
    //console.log(sat, s); return;
    try {
      var h = sat.posGd.height / s.posGd.height;
      if (h>1.1 || h<0.8) return undefined; // check
      return [s, distance3d(sat.ecf, s.ecf)];
    } catch(e) {
      // undefined
    }
  })
  .filter(x => x!=undefined)
  // restrict distance (FIXME: need real criteria)
  .filter(x => x[1]>1000 && x[1]<5000)
  // TODO: restrict based on pointing limitations
  // sort by distance (closest to furthest)
  .sort((a,b) => a[1]-b[1])
  ;
  //console.log(sat.conn);
}

function draw_sat(sat, selected_sats) {
  var pos = sat.posGd;

  try {
    pos.longitude
  }
  catch (e) {
    return
  }

  if (control.zen && !selected_sats.includes(sat)) return;

  var name = sat.name;
  var ln = pos.longitude * DEGREES, lt = pos.latitude * DEGREES, sz=.4;
  var route = get_satellite_shape(ln, lt, sz, pos.height);
  var detail = false;

  sat_context.fillStyle = pos.height > control.altitude_threshold ? "red" : "blue";
  sat_context.strokeStyle = pos.height > control.altitude_threshold ? "red" : "blue";
  if (selected_sats.indexOf(sat)!=-1) {
    sat_context.fillStyle = "olive";
    sat_context.strokeStyle = "olive";
    detail = true;
  }
  sat_context.lineWidth = 0.25;
  sat_context.beginPath();
  sat_path(route);
  sat_context.fill();

  if (control['satellite names'] || detail) {
    // FIXME does not respect geo projection if hidden
    var xy = projection([ln, lt]);
    sat_context.font = "9px sans-serif";
    sat_context.textAlign = "center";
    sat_context.fillText(name, xy[0], xy[1]+14);
  }

  if (control.FOV || detail) {
    var night = getFootprint(pos);        
    shade_context.beginPath();
    shade_path(night);
    shade_context.fillStyle = "rgba(255,0,255,0.01)";
    shade_context.fill();
    shade_context.strokeStyle = "rgba(60,60,60,0.1)"
    shade_context.stroke();
  }

  if (control['sat-to-sat']) {
    for (i=0; i<4; i++) {
      try {
        var s = sat.conn[i][0];
      } catch(e) {
        //console.log('error', sat.name, i);
        continue;
      }
      try {
        var route = {type: "LineString", "coordinates": [
          [s.posGd.longitude * DEGREES, s.posGd.latitude * DEGREES, s.posGd.height],
          [pos.longitude * DEGREES, pos.latitude * DEGREES, pos.height]
        ]};
        sat_context.beginPath();
        if (pos.height > control.altitude_threshold) {
          sat_context.strokeStyle = "rgba(0,0,255,0.4)";
        } else {
          sat_context.strokeStyle = "rgba(0,255,0,0.4)";
        }
        sat_context.lineWidth = 0.25;
        sat_path(route);
        sat_context.stroke();
      } catch(e) {
        console.log('error', sat.name, s.name, s);
      }
    }
  }
};

function draw_terminal(trm, selected_sats) {
  var pos = trm.posGd;
  var r = trm==control._from_trm ? 6 : trm==control._to_trm ? 6 : 2;

  var ln = pos.longitude * DEGREES, lt = pos.latitude * DEGREES, sz=.2*r;
  var route = get_terminal_shape(ln, lt, sz, pos.height);

  sat_context.fillStyle = "purple";
  sat_context.beginPath();
  sat_path(route);
  sat_context.fill();

  if (control.zen) {
    if (trm!=control._from_trm && trm!=control._to_trm) return;
  }

  if (control['sat-to-ground'] || control.zen) {
    trm.conn.forEach(function(s) {
      var sat = s[0], lookangles = s[1], dist = s[2];

      if (control.zen) {
        if (!selected_sats.includes(sat)) return;
      }

      var el = lookangles.elevation * DEGREES;
      var min_el = trm.minel;

      if ((el>=min_el && el<=(180-min_el))) {
        var c = sat_context;
        route = {type: "LineString", "coordinates": [
          [pos.longitude * DEGREES, pos.latitude * DEGREES],
          [sat.posGd.longitude * DEGREES, sat.posGd.latitude * DEGREES]
        ]};
        if (dist>sat.posGd.height*3) {
          // too far?
          c.strokeStyle = "rgba(255,0,0,0.5)";
        } else {
          c.strokeStyle = "rgba(140,140,140,0.5)";
        }
        if (selected_sats.includes(sat) && (trm==control._from_trm || trm==control._to_trm)) {
          c.lineWidth = 6;
        } else {
          c.lineWidth = 1;
        }
        c.beginPath();
        sat_path(route);
        c.stroke();
      }
    });
  }
}

function draw_pop(name, pop) {
  var pos = pop.posGd;
  var r = 3;

  var ln = pos.longitude * DEGREES, lt = pos.latitude * DEGREES, sz=.2*r;
  var route = get_terminal_shape(ln, lt, sz, pos.height);

  sat_context.fillStyle = "yellow";
  sat_context.beginPath();
  sat_path(route);
  sat_context.fill();

  // POP to GW connections
  if (1) {
    pop.gw.forEach(function(gw) {
      if (gw!=control._from_trm && gw!=control._to_trm) return;

      route = {type: "LineString", "coordinates": [
        [pos.longitude * DEGREES, pos.latitude * DEGREES],
        [gw.posGd.longitude * DEGREES, gw.posGd.latitude * DEGREES]
      ]};
      //console.log(pop.name, gw.name);
      sat_context.beginPath();
      sat_context.lineWidth = 4;
      sat_context.strokeStyle = "rgba(128,128,0,0.5)";
      sat_path(route);
      sat_context.stroke();
    });
  }
}

function distance3d(p1, p2) {
  return Math.sqrt( (p1.x-p2.x)**2 + (p1.y-p2.y)**2 + (p1.z-p2.z)**2 );
}


// https://bl.ocks.org/tuckergordon/raw/ce135a88cd14991761ccdc937179c6c0/

/**
 * @returns {GeoJSON.Polygon} GeoJSON describing the satellite's current footprint on the Earth
 */
function getFootprint(pos) {
  var theta = /*this._halfAngle*/ 57 * RADIANS;

  coreAngle = _coreAngle(theta, pos.height, R_EARTH) * DEGREES;

  return d3.geoCircle()
    .center([pos.longitude * DEGREES, pos.latitude * DEGREES])
    .radius(coreAngle)();
};

/**
 * A conical satellite with half angle casts a circle on the Earth. Find the angle
 * from the center of the earth to the radius of this circle
 * @param {number} theta: Satellite half angle in radians
 * @param {number} altitude Satellite altitude
 * @param {number} r Earth radius
 * @returns {number} core angle in radians
 */
function _coreAngle(theta, altitude, r) {
  // if FOV is larger than Earth, assume it goes to the tangential point
  if (Math.sin(theta) > r / (altitude + r)) {
    return Math.acos(r / (r + altitude));
  }
  return Math.abs(Math.asin((r + altitude) * Math.sin(theta) / r)) - theta;
};

// https://bl.ocks.org/caravinden/eb0e5a2b38c8815919290fa838c6b63b
// http://bl.ocks.org/charlesdguthrie/11356441
function setup_graph() {

  d3.select("body").selectAll("svg").remove();

  if (control.conntrack == undefined) return;

  var settings = {};

  // set the dimensions and margins of the graph
  var margin = {top: 20, right: 20, bottom: 30, left: 50},
      width = 400 - margin.left - margin.right,
      height = 300 - margin.top - margin.bottom;

  {
    // set the ranges
    var y = d3.scaleBand()
              .range([height, 0])
              .padding(0.1);

    var x = d3.scaleLinear()
              .range([0, width]);

    // append the svg object to the body of the page
    // append a 'group' element to 'svg'
    // moves the 'group' element to the top left margin

    var svgp = d3.select("body").append("svg")
        .attr("class", "overlay")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .style("top", margin.top/2);

    var svg = svgp
      .append("g")
        .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");

    // add the x Axis
    var xaxis = svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .style('font-size', '9px')
        .style('font-family', font_family);

    // add the y Axis
    var yaxis = svg.append("g")
        .style('font-size', '9px')
        .style('font-family', font_family);

    svgp.append('text')
      .attr('x', '100%')
      .attr('y', '1em')
      .attr('text-anchor', 'end')
      .attr('class', 'boxtitle')
      .text('Latency + Dwell Time');

    settings.latdwell = {
      margin:margin, width:width, height:height,
      svg:svg, x:x, y:y, xaxis: xaxis, yaxis: yaxis
    }

  }
  
  {
    var svg2p = d3.select("body").append("svg")
        .attr("class", "overlay")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height/2 + margin.top + margin.bottom)
        .style("top", height + margin.top + margin.bottom + margin.top);

    var svg2 = svg2p
      .append("g")
        .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");

    height /= 2;

    var hx = d3.scaleLinear().range([0, width]).domain([0,20]);
    var hy = d3.scaleLinear().range([height, 0]);

    var hxs = svg2.append('g')
      .attr('transform', 'translate(0,'+height+')')
      .style('font-size', '9px')
      .style('font-family', font_family);

    var hys = svg2.append('g')
      .style('font-size', '9px')
      .style('font-family', font_family);

    svg2p.append('text')
      .attr('x', '100%')
      .attr('y', '1em')
      .attr('text-anchor', 'end')
      .attr('class', 'boxtitle')
      .text('Visible Satellites');

    var hist = d3.histogram()
                  .domain(hx.domain())
                  .thresholds(hx.ticks(20))
                  .value(d => d);

    settings.histogram = {hist: hist, x: hx, y: hy, svg: svg2, xaxis: hxs, yaxis: hys, height: height, width: width, data: []};
  }

  return settings;
}

var mx = 0;

function redraw_graph(data_map) {
  if (graph_settings==undefined) return;

  // temp
  var data = [];
  for (x of data_map.entries()) {
    y = x[1];
    y.sat = x[0];
    data.push(y);
  }

  {
    var settings = graph_settings.latdwell;
    var x = settings.x,
        y = settings.y,
        xaxis = settings.xaxis,
        yaxis = settings.yaxis,
        margin = settings.margin,
        svg = settings.svg,
        height = settings.height,
        width = settings.width;

    // Scale the range of the data in the domains
    mx = Math.max((mx || 0), d3.max(data.map(d => d.latency*1000))); // convert to ms
    x.domain( [0, mx] );
    // Easier to follow if we don't reorder y
    y.domain( data.sort((a,b) => a.first_seen-b.first_seen).map(d => d.sat) );
    //y.domain( data.map(d => d.sat) );

    //Bind new data to chart rows 

    //Create chart row and move to below the bottom of the chart
    var chartRow = svg.selectAll("g.chartRow")
      .data(data);
      
    var newRow = chartRow
      .enter()
        .append("g")
        .attr("class", "chartRow")
        .attr("transform", "translate(0," + height + margin.top + margin.bottom + ")");

    // // append the rectangles for the bar chart
    // svg.selectAll(".bar")
    //     .data(data)
    //   .enter().append("rect")
    //     .attr("class", "bar")
    //     //.attr("x", function(d) { return x(d.latency); })
    //     .attr("width", function(d) {return x(d.latency); } )
    //     .attr("y", function(d) { return y(d.sat); })
    //     .attr("height", y.bandwidth());

    //Add rectangles
    newRow.insert("rect")
      .attr("class", "bar")
      .attr("x", 0)
      //.attr("opacity", 0)
      .attr("opacity", 1)
      .attr("height", y.bandwidth())
      .attr("width", d => x(d.latency*1000));

    // min/max latency
    newRow.insert("rect")
      .attr("class", "range")
      .attr("x", d => x(d.min_latency*1000))
      //.attr("opacity", 0)
      .attr("opacity", 1)
      .attr("height", 5)
      .attr("width", d => x((d.max_latency-d.min_latency)*1000));

    //Add value labels
    newRow.append("text")
      .attr("class", "label")
      .attr("y", y.bandwidth()/2)
      .attr("x", 0)
      //.attr("opacity", 0)
      .attr("opacity", 1)
      .attr("dy", ".35em")
      .attr("dx", "0.5em")
      ;//.text(d => d.latency);

    //Update bar widths
    chartRow.select(".bar")
      .transition()
      .duration(10)
      .attr("class", d => d.active ? "bar active" : "bar inactive")
      .attr("height", y.bandwidth())
      .attr("width", d => x(d.latency*1000))
      .attr("opacity", 1);

    // min/max latency
    chartRow.select(".range")
      .transition()
      .duration(10)
      .attr("x", d => x(d.min_latency*1000))
      //.attr("opacity", 0)
      .attr("opacity", 1)
      .attr("height", y.bandwidth()/3)
      .attr("width", d => x((d.max_latency-d.min_latency)*1000));

    //Update data labels
    chartRow.select(".label")
      //.update()
      //.transition()
      //.duration(10)
      .attr("y", y.bandwidth()/2)
      .attr("opacity", 1)
      //.tween("text", function(d) { 
      //   var i = d3.interpolate(+this.textContent.replace(/\,/g,''), +d.latency);
      //   return function(t) {
      //     this.textContent = Math.round(i(t));
      //   };
      // });
      .text(d => 
          d.active ? d3.formatPrefix(".1s", 1e-3)(d.latency)+"s" // display as ms
                : d3.format(".1f")((d.last_seen - d.first_seen)/1000/60)+" min");
      
    //Fade out and remove exit elements
    chartRow.exit()
      //.transition()
      //.style("opacity", "0")
      //.attr("transform", "translate(0," + (height + margin.top + margin.bottom) + ")")
      .remove();

    //REORDER ROWS

    var delay = function(d, i) { return 200 + i * 30; };

    chartRow.merge(chartRow)
      .transition()
      //.delay(delay)
      //.duration(900)
      .duration(30)
      .attr("transform", function(d){ return "translate(0," + y(d.sat) + ")"; });
      

    // update the x Axis
    xaxis
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    // update the y Axis
    yaxis
        .call(d3.axisLeft(y));
  }

  ///////////////////////////////

  {
    var histogram = graph_settings.histogram;
    var hdata = data.filter(d => d.active);
    var x = histogram.x, y = histogram.y;

    histogram.data.push(hdata.length);

    var bins = histogram.hist(histogram.data);
    //console.log("bins", bins);
    y.domain([0, d3.max(bins, function(d) { return d.length; })]);
    histogram.xaxis.call(d3.axisBottom(histogram.x));
    histogram.yaxis.call(d3.axisLeft(histogram.y));

    var chartRow = histogram.svg.selectAll("g.histCol")
      .data(bins);
      
    var newRow = chartRow
      .enter()
        .append("g")
        .attr("class", "histCol");
        //.attr("transform", "translate(0," + height + margin.top + margin.bottom + ")");

    //Add rectangles
    newRow.insert("rect")
      .attr("class", "bar")
      .attr("x", 0)
      //.attr("opacity", 0)
      .attr("opacity", 1);
      //.attr("height", y.bandwidth())
      //.attr("width", d => x(d.latency*1000));

    chartRow.select(".bar")
      .transition()
      .duration(10)
      .attr("x", 1)
      .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
      .attr("width", function(d) { return Math.max(0, x(d.x1) - x(d.x0) - 1); })
      .attr("height", function(d) { return Math.max(d.length>0 ? 2 : 0, histogram.height - y(d.length)); })
      .style("fill", "#69b3a2");
  }
}

// adapted from:
//  https://observablehq.com/@mbostock/solar-terminator
//  https://bl.ocks.org/vasturiano/9bdeddb97d5c71f425743442761d5384
function plotshade(time, context, path) {
  context.clearRect(0,0,width,height);
  if (control.shade) {
    var sun = solarPosition(time);
    var night = d3.geoCircle()
      .radius(90)
      .center(antipode(sun))
    ();

    context.beginPath();
    path(night);
    context.fillStyle = "rgba(0,0,255,0.1)";
    context.fill();
  }
}

function get_terminal_shape(ln, lt, sz, height) {
  var circle = d3.geoCircle().center([ln, lt]).radius(sz);
  var route = circle();
  return route;
}

function get_satellite_shape(ln, lt, sz, height) {
  // much faster than the geoCircle above
  var route = {
    type: "LineString", 
    coordinates: [
      [ln-sz, lt-sz, height],
      [ln+sz, lt-sz, height],
      [ln+sz, lt+sz, height],
      [ln-sz, lt+sz, height],
      [ln-sz, lt-sz, height],
    ]};
  return route;
}

d3.select(self.frameElement).style("height", height + "px");

//graph_settings = setup_graph();

// random bit is to avoid caching: https://stackoverflow.com/questions/13053096/avoid-data-caching-when-using-d3-text/13054513
d3.queue()
  // slow when zooming/panning, but much better resolution: 
  .defer(d3.json, "https://raw.githubusercontent.com/d3/d3.github.com/master/world-50m.v1.json")
  // low resolution map:
  .defer(d3.json, "https://raw.githubusercontent.com/d3/d3.github.com/master/world-110m.v1.json")
  .defer(d3.tsv, "pops.txt"+ '?' + Math.floor(Math.random() * 100000))
  .defer(d3.tsv, "gateways.txt"+ '?' + Math.floor(Math.random() * 100000))
  .defer(d3.tsv, "terminals.txt"+ '?' + Math.floor(Math.random() * 100000))
  .defer(d3.text, "satellites.txt"+ '?' + Math.floor(Math.random() * 100000))
  .await(function(error, world_detailed, world, pops, gateways, terminals, satellites) {
    if (error) throw error;
    load_world(world_detailed, world);
    control.create_controls();
    load_pops(pops);
    load_terminals(gateways.concat(terminals));
    load_satellites(satellites);
    run();
  });

</script>
