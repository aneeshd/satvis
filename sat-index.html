<!DOCTYPE html>
<meta charset="utf-8">
<style>
canvas {
  position: absolute;
}
</style>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo/1.9.1/d3-geo.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo-projection/2.4.0/d3-geo-projection.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
<script src="satellite.js"></script>
<script src="solar-positions.js"></script>
<script>

var magnify = 1.5;

var width = 960 * magnify,
    height = 600 * magnify;

var radius = height / 2 - 5,
    scale = radius,
    velocity = .02;

//var projection = d3.geoHyperelliptical() //d3.geo.mtFlatPolarQuartic() //d3.geo.kavrayskiy7()
//var projection = d3.geoMtFlatPolarQuartic() //d3.geo.kavrayskiy7()
//var projection = d3.geoNaturalEarth1() //d3.geoProjection(d3.geoMtFlatPolarQuarticRaw) //d3.geo.kavrayskiy7()
var projection = d3.geoProjection(d3.geoMtFlatPolarQuarticRaw) //d3.geo.kavrayskiy7()
    .scale(170 * magnify)
    .translate([width / 2, height / 2])
    .precision(.1);

var graticule = d3.geoGraticule();

var map_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var sat_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var stats_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var shade_canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var color = d3.scaleOrdinal()
  .range(["#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#ffffbf","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2"]);

var map_context = map_canvas.node().getContext("2d");
var sat_context = sat_canvas.node().getContext("2d");
var stats_context = stats_canvas.node().getContext("2d");
var shade_context = shade_canvas.node().getContext("2d");

var path = d3.geoPath()
    .projection(projection)
    .context(map_context);

var shade_path = d3.geoPath()
    .projection(projection)
    .context(shade_context);

var timeFormat = d3.timeFormat("%Y-%m-%d %H:%M");

d3.json("world-110m.json", function(error, world) {
  if (error) throw error;

  function plotglobe() {
    var land = topojson.feature(world, world.objects.land);

    map_context.clearRect(0,0,width,height);

    map_context.fillStyle = "#ccc";
    map_context.beginPath();
    path(land);
    map_context.fill();

    map_context.fillStyle = "#555";
    map_context.beginPath();
    path(topojson.feature(world, world.objects.countries));
    map_context.lineWidth = 0.1;
    map_context.stroke();

    map_context.strokeStyle = "#ddd";
    map_context.beginPath();
    path(graticule());
    map_context.lineWidth = 1;
    map_context.stroke();

    map_context.beginPath();
    path(graticule.outline());
    map_context.lineWidth = 1;
    map_context.stroke();
  }

  // adapted from:
  //  https://observablehq.com/@mbostock/solar-terminator
  //  https://bl.ocks.org/vasturiano/9bdeddb97d5c71f425743442761d5384
  function plotshade(time) {
    shade_context.clearRect(0,0,width,height);
    var sun = solarPosition(time);
    var night = d3.geoCircle()
      .radius(90)
      .center(antipode(sun))
    ()
       
    shade_context.beginPath();
    shade_path(night);
    shade_context.fillStyle = "rgba(0,0,255,0.1)";
    shade_context.fill();
  }

  plotglobe();

  d3.text("satellites.txt", function(error2, data) {
    if (error2) throw error2;

    var stations = [];
    var lines = data.split("\n");
    lines.forEach(function(line) {
      if (line.length == 0) return;

      if (line[0] == "1") {
        var obj = stations[stations.length-1];
        obj.tle1 = line;
        return; 
      }

      if (line[0] == "2") {
        var obj = stations[stations.length-1];
        obj.tle2 = line;
        return; 
      }
      
      //if (stations.length==12) return;
      stations.push({
        name: line.trim()
      });
    });

    var now = new Date();

    d3.timer(function(elapsed) {
      var time = new Date(now.getTime() + 300*elapsed);

      if (0) {
         const config = {
                 speed: 0.005,
                 verticalTilt: -30,
                 horizontalTilt: 0
               }
         projection.rotate([config.speed * elapsed - 120, config.verticalTilt, config.horizontalTilt]);
         plotglobe();
      }
      
      stats_context.clearRect(0,0,width,height);
      stats_context.globalAlpha = .95;
      stats_context.drawImage(sat_canvas.node(),0,0);
      sat_context.clearRect(0,0,width,height);
      sat_context.drawImage(stats_canvas.node(),0,0);

      // stats_context.clearRect(0,0,width,height);
      stats_context.font = "bold 14px sans-serif";
      stats_context.fillStyle = "#333";
      stats_context.textAlign = "center";
      stats_context.fillText(timeFormat(time),width/2,20);

      stations.forEach(function(d) {
        plotsat(d, time);
      });

      plotshade(time);
    });

    function plotsat(station, time) {
      var satrec = satellite.twoline2satrec(station.tle1, station.tle2);

      // increment time by 5 minutes

      var positionAndVelocity = satellite.propagate(
          satrec,
          time.getUTCFullYear(),
          time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
          time.getUTCDate(),
          time.getUTCHours(),
          time.getUTCMinutes(),
          time.getUTCSeconds()
      );

      if (!positionAndVelocity.position) {
        if (time.getTime() - now.getTime() > 1000) return;
        console.log("No position data for:");
        console.log(station, satrec);
        return;
      }

      var gmst = satellite.gstimeFromDate(
          time.getUTCFullYear(),
          time.getUTCMonth() + 1, // Note, this function requires months in range 1-12.
          time.getUTCDate(),
          time.getUTCHours(),
          time.getUTCMinutes(),
          time.getUTCSeconds()
      );

      // The position_velocity result is a key-value pair of ECI coordinates.
      // These are the base results from which all other coordinates are derived.
      var positionEci = positionAndVelocity.position,
          velocityEci = positionAndVelocity.velocity;

      var positionGd = satellite.eciToGeodetic(positionEci, gmst)
      drawSat(station, positionGd);
    };
  });

  function drawSat(sat, pos) {
    var name = sat.name;
    var xy = projection([pos.longitude*180/Math.PI, pos.latitude*180/Math.PI]);
    sat_context.fillStyle = color(name.substring(0,5));
    sat_context.beginPath();
    sat_context.arc(xy[0],xy[1],2,0,2*Math.PI);
    sat_context.fill();

    stats_context.font = "9px sans-serif";
    stats_context.textAlign = "center";
    //stats_context.fillText(name, xy[0], xy[1]+14);
  };
});

d3.select(self.frameElement).style("height", height + "px");

</script>
